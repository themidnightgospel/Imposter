# Imposter.CodeGenerator – Property Default Behaviour

## Syntax Construction Guidelines

When authoring or updating Roslyn syntax inside the generator, always prefer the shared helpers in `SyntaxFactoryHelper` for common literals and identifiers. In particular:

- Use `SyntaxFactoryHelper.True` instead of `LiteralExpression(SyntaxKind.TrueLiteralExpression)`.
- Use `SyntaxFactoryHelper.False` instead of `LiteralExpression(SyntaxKind.FalseLiteralExpression)`.
- Use `SyntaxFactoryHelper.Null` instead of `LiteralExpression(SyntaxKind.DefaultLiteralExpression)` or other default/null literal expressions.
- Use `SyntaxFactoryHelper.Var` instead of `IdentifierName("var")`.
- Use `SyntaxFactoryHelper.And`/`SyntaxFactoryHelper.Or` instead of `BinaryExpression(SyntaxKind.LogicalAndExpression)` or `BinaryExpression(SyntaxKind.LogicalOrExpression)`.
- Use `SyntaxFactoryHelper.Not` instead of `PrefixUnaryExpression(SyntaxKind.LogicalNotExpression)`.
- Use `SyntaxFactoryHelper.ToStatementSyntax` instead of manually creating `ExpressionStatement` nodes when wrapping expressions as statements.

Keeping literals and identifier shorthands on the helper surface avoids redundant Roslyn allocations and ensures we emit syntax consistently across features.

Every generated compilation unit now begins with the standard `// <auto-generated />` header before the nullable pragmas so downstream tooling can recognize analyzer output automatically.

This note documents the default behaviour for class property imposters when the target property has an initializer.

## Class Property Initializers

When an overridable property on a class has an initializer (e.g. `public virtual int A { get; set; } = 11;`), the imposter’s default property behaviour now reflects that initialized value on first read.

### How it works

- For class targets, when default behaviour is active and no explicit getter setup exists, the getter will:
  - On the first read, if a base getter is available, seed the internal backing field from the base getter value, then return it.
  - On subsequent reads (and sets), continue to behave like an auto-property until explicitly configured.
  - If `UseBaseImplementation` is enabled, calls go directly to the base implementation and throw if base is not available.

### Rationale

This mirrors C# semantics where property initializers are applied in the base class's initialization path. The imposter should surface the same initialized state by default.

### Tests

See `tests/Imposter.Tests/Features/PropertyImposter/PropertyDefaultBehaviour.cs:27` which verifies the first read returns the initializer value.

## Event `UseBaseImplementation`

Event imposters now expose `.UseBaseImplementation()` on their fluent builder whenever the target event belongs to an overridable class member (i.e., virtual/override events with non-abstract accessors). The builder still tracks and verifies subscriptions, but when the flag is enabled it will:

- Capture the base `add`/`remove` implementations via the event accessors and invoke them whenever handlers are subscribed/unsubscribed.
- Throw a `MissingImposterException` that includes the event display name if the base implementation is requested but unavailable (e.g., the imposter is used outside a class target).

This keeps event behaviour aligned with properties/methods: opting into base execution forwards to the real member first while retaining all imposter diagnostics.

### Tests

- `tests/Imposter.Tests/Features/ClassImposter/ProtectedOverrideableMembersClassImposterTests.cs` (`GivenProtectedEventUseBaseImplementation_WhenSubscribed_ThenBaseEventReceivesHandler`) covers protected event subscriptions.
- `tests/Imposter.Tests/Features/ClassImposter/ProtectedOverrideableMembersClassImposterTests.cs` (`GivenAsyncEventUseBaseImplementation_WhenUnsubscribed_ThenBaseEventIsCleared`) covers async task-based events and unsubscriptions.

## Method Arguments Criteria Extensions

Method imposters emit helper extensions for arguments criteria (e.g., `.Matches(...)` and `.As<T>()`) via `ArgumentsCriteriaBuilder.BuildExtensions`. These helper classes now live inside the generated imposter type rather than as additional namespace-level declarations. Nesting keeps the generated surface area smaller, avoids polluting the namespace with per-method helpers, and makes it easier for consuming code to locate the helpers next to the related method metadata. No behavioural changes were made-only the containment of the generated extension classes.

When emitting the `.As<...>()` helper for a generic method's arguments criteria we now request target type parameter names from the `GenericTypeParameterNameSet` (the same allocator used by invocation setup metadata). This prevents generator-authored names such as `TTarget`/`UTarget` from shadowing identically named user-provided type parameters, eliminating compiler errors like the `CS1503` mismatch observed in `IMethodGenericTypeParameterCollisionTargetImposter`. The generated helper always operates with unique synthetic type parameter identifiers even when the consumer uses the same suffixes.

## Event Deduplication

Interface targets can inherit the same event signature from multiple base interfaces. We now collapse those duplicates during metadata collection using the event name plus its delegate type (compared via `SymbolEqualityComparer`). Case-sensitive collisions (e.g., `raise` vs `Raise`) are still emitted independently so consumers can configure both builders. This prevents the generator from emitting duplicate event members such as multiple `Raise` builders on `IEventDuplicateChildCollisionTargetImposter` while preserving legitimate case-differing events.

## Internal Name Reservation

The `NameSet` that chooses nested type names (`ImposterTargetInstance`) and private fields (e.g., `_imposterInstance`, `_invocationBehavior`) is now pre-seeded with every public member name the generated imposter will expose: all target properties, indexers, methods, and events (case-sensitive). By reserving those identifiers before we allocate internal names, collisions like an event named `_imposterInstance` will force the internal field to be suffixed (`_imposterInstance_1`) instead of redefining the event member.

## Imposter Type Modifiers

Generated imposter types now emit the `sealed` modifier alongside `public`. We do not support end-users inheriting from these Roslyn-generated types, and sealing them prevents consumers from subclassing a type that was never designed for extension (the internal fields/constructors assume a closed hierarchy). This change also keeps analyzer output consistent with other imposter helper types, which were already emitted as sealed builders.

## Method Imposter Helper Renames

Method imposters (and their generic adapters/collections) now expose `HasMatchingInvocationImposterGroup` instead of `HasMatchingSetup`. The updated name reflects that the helper searches for an existing invocation imposter group rather than setup metadata, and keeps terminology aligned with the rest of the API that refers to “invocation imposters.” Update any docs or samples that referenced the old helper name.

## Invocation Queue Thread Safety

`InvocationSetupBuilder.GetInvocationImposter()` now returns the dequeued invocation object immediately after optionally updating `_lastestInvocationImposter`. Previously the method returned `_lastestInvocationImposter` even when the queue produced a newer entry, which allowed a racing thread to overwrite `_lastestInvocationImposter` before the first caller observed its scheduled result. The revised flow only falls back to `_lastestInvocationImposter` when the queue is empty, preventing lost sequential setups under concurrent access.

Property getter builders mirror this behaviour: each getter now dequeues into a local variable, computes `next = returnValue ?? _lastReturnValue`, persists `next` (when present) back into `_lastReturnValue`, and immediately returns `next()`. This preserves the "repeat last setup" semantics without allowing concurrent getters to clobber one another's delegates.

Indexer getter builders now use the same `next` pattern, throwing the existing `MissingImposterException` if both the queue and cached delegate are empty, and otherwise updating `_lastReturnValue` only after capturing the thread-local delegate that gets returned to the caller.

### Tests

- `tests/Imposter.Tests/Features/MethodImposter/ThreadSafetyTests.cs` (`GivenSequentialReturnsSetup_WhenMethodsInvokedConcurrently_ShouldConsumeUniqueValues`) exercises the interlocked start barrier that exposed the race.
- `tests/Imposter.Tests/Features/PropertyImposter/ThreadSafetyTests.cs` (`GivenSequentialReturnsSetup_WhenAccessedConcurrently_ShouldWorkCorrectly`) stresses sequential getter setups under contention.
