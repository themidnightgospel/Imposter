{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>Imposter \u2014 The Fastest and Most Memory-Efficient Mocking Library</p>"},{"location":"#installation","title":"Installation","text":"PackageReference.NET CLIPackage Manager <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Imposter\" Version=\"*\" PrivateAssets=\"all\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <pre><code>dotnet add package Imposter\n</code></pre> <pre><code>Install-Package Imposter\n</code></pre> <p>This package includes both the source generator (analyzer) and the runtime abstractions.</p> <p>Pro tip</p> <p>To inspect generated sources locally, set <code>EmitCompilerGeneratedFiles</code> and <code>CompilerGeneratedFilesOutputPath</code> in your project. Remove these before committing. <pre><code>&lt;!-- Source code generation settings--&gt;\n&lt;PropertyGroup&gt;\n    &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;\n    &lt;CompilerGeneratedFilesOutputPath&gt;GeneratedFiles&lt;/CompilerGeneratedFilesOutputPath&gt;\n&lt;/PropertyGroup&gt;\n\n&lt;!-- Include but don't compile generated code. The system will already compile the code, but this will make it visible for reference.--&gt;\n&lt;ItemGroup&gt;\n    &lt;Compile Remove=\"GeneratedFiles\\**\"/&gt;\n    &lt;None Include=\"GeneratedFiles\\**\"/&gt;\n&lt;/ItemGroup&gt;\n</code></pre></p>"},{"location":"#generate-an-imposter-for-an-interface","title":"Generate an imposter for an interface","text":"<p>Annotate the target type with the assembly level attribute and build. The generator produces a <code>&lt;TypeName&gt;Imposter</code> you can new up in code.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(IMyService))]\n\npublic interface IMyService\n{\n    int Increment(int value);\n}\n</code></pre> <p>Note</p> <p>Imposter and the imposter target (type that you generate an impsoter for) does not have to live in the same assembly. You can generate imposters for types in referenced assemblies.</p> <p>After a build, use the generated type:</p> C# 14C# 9-13 <pre><code>var imposter = IMyService.Imposter();\nimposter.Increment(Arg&lt;int&gt;.Any()).Returns(3);\n\nvar service = imposter.Instance();\nservice.Increment(1).ShouldBe(3);\n</code></pre> <p>Use the generated imposter type directly:</p> <pre><code>var imposter = new IMyServiceImposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <p>Generate imposter for a class</p> <p>Warning</p> <p>Only non-sealed classes can be impersonated.</p> <p>In the exact same fashion, you can generate imposter for classes.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(BaseService))]\n\npublic abstract class BaseService\n{\n    public virtual int GetNumber() =&gt; 0;\n}\n</code></pre> <p>After a build, use the generated type:</p> C# 14C# 9-13 <pre><code>var imposter = BaseService.Imposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <pre><code>var imposter = new BaseServiceImposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <p>Note</p> <p>For classes, only virtual or abstract members can be impersonated.</p> <p>Warning</p> <p>Minimum supported C# version is 9.0</p> <p>Next steps</p> <ul> <li>Methods</li> <li>Properties</li> <li>Indexers</li> <li>Events</li> <li>Key API Reference</li> </ul>"},{"location":"arguments-matching/","title":"Arguments Matching","text":"<p>How imposters decide which setup applies for a given call.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.ArgumentsMatching.IArgumentMatchingService))]\n\npublic interface IArgumentMatchingService\n{\n    int Add(int a, int b);\n    int Increment(int value);\n    int Sum(params int[] values);\n    string Format(string template, string value);\n    int InOnly(in int input);\n    int RefOnly(ref int state);\n    int OutOnly(out int result);\n}\n</code></pre>"},{"location":"arguments-matching/#basics-value-vs-matcher","title":"Basics: value vs matcher","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\n// Implicit equality matchers.\n// Equivalent to imposter.Add(Arg&lt;int&gt;.Is(1), Arg&lt;int&gt;.Is(2)).Returns(3);\nimposter.Add(1, 2).Returns(3);\n\n// Explicit equality matchers\nimposter.Add(Arg&lt;int&gt;.Is(1), Arg&lt;int&gt;.Is(2)).Returns(30);\n\n// Wildcard on first argument, fixed second\nimposter.Add(Arg&lt;int&gt;.Any(), 0).Returns(0);\n\nservice.Add(1, 2);  // 30\nservice.Add(10, 0); // 0\nservice.Add(5, 5);  // 0 (default(int) in Implicit mode)\n</code></pre>"},{"location":"arguments-matching/#predicates-and-ranges","title":"Predicates and ranges","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &lt; 0)).Returns(-1);\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt;= 0 &amp;&amp; x &lt;= 10)).Returns(10);\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 10)).Returns(100);\n\nservice.Increment(-5);  // -1\nservice.Increment(3);   // 10\nservice.Increment(50);  // 100\n</code></pre>"},{"location":"arguments-matching/#negation-and-defaults","title":"Negation and defaults","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\n// Not equal\nimposter.Increment(Arg&lt;int&gt;.IsNot(0)).Returns(1);\n\n// Default(T)\nimposter.Increment(Arg&lt;int&gt;.IsDefault()).Returns(-1);\n\nservice.Increment(0);  // -1 (default)\nservice.Increment(5);  // 1  (IsNot)\n</code></pre>"},{"location":"arguments-matching/#membership-and-collections","title":"Membership and collections","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\n// Discrete set\nimposter.Increment(Arg&lt;int&gt;.IsIn(new[] { 1, 2, 3 })).Returns(10);\nimposter.Increment(Arg&lt;int&gt;.IsNotIn(new[] { 1, 2, 3 })).Returns(99);\n\nservice.Increment(2);  // 10\nservice.Increment(5);  // 99\n</code></pre>"},{"location":"arguments-matching/#ref-out-in-parameters","title":"Ref / out / in parameters","text":""},{"location":"arguments-matching/#in-parameters","title":"<code>in</code> parameters","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\nimposter.InOnly(Arg&lt;int&gt;.Is(x =&gt; x &gt; 0)).Returns(99);\n\nint input = 5;\nservice.InOnly(in input); // 99\n</code></pre>"},{"location":"arguments-matching/#ref-parameters","title":"<code>ref</code> parameters","text":"<p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\nimposter\n    .RefOnly(Arg&lt;int&gt;.Is(x =&gt; x &gt;= 0))\n    .Returns(\n        (ref int state) =&gt;\n        {\n            state += 10;\n            return state;\n        }\n    );\n\nint state = 1;\nservice.RefOnly(ref state); // 11, state is now 11\n</code></pre>"},{"location":"arguments-matching/#out-parameters","title":"<code>out</code> parameters","text":"<p>Note</p> <p><code>out</code> arguments are not inputs and hence they are always treated as wildcards for matching. Use <code>OutArg&lt;T&gt;.Any()</code> to indicate \"any <code>out</code> value\".</p> <p>Example</p> <pre><code>var imposter = new IArgumentMatchingServiceImposter();\nvar service = imposter.Instance();\n\nimposter\n    .OutOnly(OutArg&lt;int&gt;.Any())\n    .Returns(\n        (out int value) =&gt;\n        {\n            value = 42;\n            return 1;\n        }\n    );\n\nint result;\nservice.OutOnly(out result); // result == 42\n</code></pre>"},{"location":"base-implementation/","title":"Base Implementation","text":"<p>Forward calls from imposters to the original class implementation instead of configuring custom behavior.</p> <p>Note</p> <p>Base Implementation is available for overrideable and non-abstract class members only.</p>"},{"location":"base-implementation/#methods","title":"Methods","text":"<p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    public virtual int Add(int a, int b)\n        =&gt; a + b;\n\n    public virtual System.Threading.Tasks.Task ProcessAsync(string s)\n        =&gt; System.Threading.Tasks.Task.CompletedTask;\n\n    public virtual int MightFail(int v)\n        =&gt; throw new System.InvalidOperationException(\"fail\");\n}\n</code></pre>"},{"location":"base-implementation/#basic-example","title":"Basic example","text":"<p>Example</p> <pre><code>var imposter = new MyServiceImposter();\nvar service = imposter.Instance();\n\n// Forward calls to the original implementation\nimposter.Add(Arg&lt;int&gt;.Any(), Arg&lt;int&gt;.Any()).UseBaseImplementation();\n\nservice.Add(2, 5); // 7 (calls MyService.Add)\n</code></pre>"},{"location":"base-implementation/#with-matchers-and-sequencing","title":"With matchers and sequencing","text":"<p>Example</p> <pre><code>var imposter = new MyServiceImposter();\nvar service = imposter.Instance();\n\n// Otherwise return a specific value (fallback)\nimposter.Add(Arg&lt;int&gt;.Any(), Arg&lt;int&gt;.Any()).Returns(-1);\n\n// Only forward when the first value is positive (more specific rule)\nimposter.Add(Arg&lt;int&gt;.Is(x =&gt; x &gt; 0), Arg&lt;int&gt;.Any()).UseBaseImplementation();\n\nservice.Add(2, 3);  // 5 (base)\nservice.Add(-2, 3); // -1 (fallback)\n</code></pre> <p>Sequence with <code>Then()</code> if you need to call base once and then switch behavior:</p> <p>Example</p> <pre><code>var imposter = new MyServiceImposter();\nvar service = imposter.Instance();\n\nimposter.Add(Arg&lt;int&gt;.Any(), Arg&lt;int&gt;.Any())\n   .UseBaseImplementation()\n   .Then()\n   .Returns(100);\n\nservice.Add(1, 1); // base -&gt; 2\nservice.Add(1, 1); // 100\n</code></pre>"},{"location":"base-implementation/#async-and-exceptions","title":"Async and exceptions","text":"<p>Example</p> <pre><code>var imposter = new MyServiceImposter();\nvar service = imposter.Instance();\n\n// Async forwarding\nimposter.ProcessAsync(Arg&lt;string&gt;.Any()).UseBaseImplementation();\nawait service.ProcessAsync(\"x\"); // runs class implementation\n\n// Exceptions from base flow to the caller\nimposter.MightFail(Arg&lt;int&gt;.Any()).UseBaseImplementation();\nShould.Throw&lt;InvalidOperationException&gt;(() =&gt; service.MightFail(5));\n</code></pre>"},{"location":"base-implementation/#properties","title":"Properties","text":"<p>For class targets with virtual properties, you can forward getters and setters to the base implementation.</p> <p>Example</p> <pre><code>var imposter = new ClassWithVirtualPropertyImposter();\nimposter.VirtualProperty.Getter().UseBaseImplementation();\n\nvar service = imposter.Instance();\nvar value = service.VirtualProperty; // uses base implementation\n</code></pre> <p>Example</p> <pre><code>var imposter = new ClassWithVirtualPropertyImposter();\nimposter.VirtualProperty.Setter(Arg&lt;string&gt;.Any()).UseBaseImplementation();\n\nvar service = imposter.Instance();\nservice.VirtualProperty = \"value\"; // uses base implementation\n</code></pre> <p>This is useful when you want imposters to preserve class invariants or initialization logic defined in virtual properties.</p>"},{"location":"base-implementation/#indexers","title":"Indexers","text":"<p>Class targets with virtual indexers also support <code>UseBaseImplementation()</code> on getter and setter builders.</p> <p>Example</p> <pre><code>var imposter = new IIndexerSetupSutImposter();\nimposter[Arg&lt;int&gt;.Any(), Arg&lt;string&gt;.Any(), Arg&lt;object&gt;.Any()].Getter().UseBaseImplementation();\n\nvar service = imposter.Instance();\nvar result = service[1, \"key\", new object()]; // uses base implementation\n</code></pre> <p>Example</p> <pre><code>var imposter = new IIndexerSetupSutImposter();\nimposter[Arg&lt;int&gt;.Any(), Arg&lt;string&gt;.Any(), Arg&lt;object&gt;.Any()].Setter().UseBaseImplementation();\n\nvar service = imposter.Instance();\nservice[1, \"key\", new object()] = 42; // uses base implementation\n</code></pre> <p>Use this when a virtual indexer encapsulates non-trivial logic (e.g., backing collections or validation) and you want imposters to reuse it rather than reimplement it in tests.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Overview of performance measurements using BenchmarkDotNet. The suite compares Imposter with popular impersonation libraries for common setup and invocation patterns.</p>"},{"location":"benchmarks/#whats-measured","title":"What\u2019s Measured","text":"<ul> <li>Setup throughput: configuring return values for a simple method.</li> <li>Invocation throughput: calling the configured method.</li> <li>Parameterized iterations: 1, 10, 100, 1000 setups + calls.</li> </ul> <p>Primary scenario (see <code>ImposterVsOthersBenchmark.cs</code>):</p> <pre><code>public interface ICalculator { int Square(int input); }\n// Benchmarks compare: Imposter vs Moq vs NSubstitute\n</code></pre> <p>Additional microbenchmarks cover generator internals (syntax builders) and struct behaviors.</p>"},{"location":"benchmarks/#benchmark-results","title":"Benchmark Results","text":"<pre><code>BenchmarkDotNet v0.15.2, Windows 11 (10.0.26200.6899)\n13th Gen Intel Core i9-13900HX 2.20GHz, 1 CPU, 32 logical and 24 physical cores\n.NET SDK 10.0.100-rc.2.25502.107\n  [Host]     : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX2\n  DefaultJob : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX2\n\n\n| Method   | Iteration | Mean            | Error           | StdDev          | Gen0      | Gen1      | Gen2     | Allocated   |\n|--------- |---------- |----------------:|----------------:|----------------:|----------:|----------:|---------:|------------:|\n| Imposter     | 1         |     57,888.4 ns |     1,152.97 ns |     1,861.83 ns |    0.6104 |    0.4883 |        - |    13.06 KB |\n| NSub     | 1         |      1,792.1 ns |        35.42 ns |        48.48 ns |    0.4120 |         - |        - |     7.73 KB |\n| Imposter | 1         |        187.8 ns |         3.41 ns |         3.02 ns |    0.1304 |    0.0010 |        - |      2.4 KB |\n| Imposter     | 10        |    561,381.0 ns |     9,870.99 ns |     8,750.38 ns |    5.8594 |    4.8828 |        - |    115.8 KB |\n| NSub     | 10        |     11,091.9 ns |       220.34 ns |       506.26 ns |    1.5869 |         - |        - |    29.18 KB |\n| Imposter | 10        |      1,897.5 ns |        25.95 ns |        23.01 ns |    1.2169 |    0.0877 |        - |    22.37 KB |\n| Imposter     | 100       |  5,659,959.7 ns |   106,879.17 ns |    89,248.95 ns |   62.5000 |   46.8750 |        - |  1417.69 KB |\n| NSub     | 100       |    317,054.3 ns |     5,962.06 ns |     5,576.92 ns |   13.1836 |    4.3945 |        - |   247.15 KB |\n| Imposter | 100       |     34,266.0 ns |       658.78 ns |       809.04 ns |   12.0239 |    5.6152 |        - |   222.05 KB |\n| Imposter     | 1000      | 87,595,090.5 ns | 1,733,629.98 ns | 1,536,817.82 ns | 2000.0000 | 1000.0000 | 666.6667 | 42282.98 KB |\n| NSub     | 1000      | 25,822,022.4 ns |   513,318.30 ns |   630,401.02 ns |  125.0000 |   62.5000 |        - |  2420.71 KB |\n| Imposter | 1000      |  2,635,074.0 ns |    51,717.64 ns |    61,566.17 ns |  117.1875 |  101.5625 |        - |  2218.93 KB |\n</code></pre>"},{"location":"benchmarks/#run-locally","title":"Run Locally","text":"<pre><code>dotnet run -c Release -p benchmarks/Imposter.Benchmarks/Imposter.Benchmarks.csproj\n</code></pre> <p>BenchmarkDotNet will emit results under <code>benchmarks/Imposter.Benchmarks/BenchmarkDotNet.Artifacts/</code> (Markdown, CSV, and summary files).</p>"},{"location":"cheat-sheet/","title":"Cheat Sheet","text":"<p>Quick reference for common operations.</p>"},{"location":"cheat-sheet/#create-imposter","title":"Create Imposter","text":"<pre><code>// C# 14+\nvar imp = IMyService.Imposter();\nvar svc = imp.Instance();\n\n// C# 9\u201313\nvar imp2 = new IMyServiceImposter();\nvar svc2 = imp2.Instance();\n</code></pre>"},{"location":"cheat-sheet/#mode","title":"Mode","text":"<pre><code>var implicitImposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar explicitImposter = new IMyServiceImposter(ImposterMode.Explicit);\n</code></pre>"},{"location":"cheat-sheet/#methods","title":"Methods","text":"<pre><code>// Return values\nimp.GetNumber().Returns(42);\nimp.GetNumber().Returns(() =&gt; 42);\n\n// Sequencing\nimp.GetNumber().Returns(1).Then().Returns(2).Then().Throws&lt;InvalidOperationException&gt;();\n\n// Arguments\nimp.Increment(Arg&lt;int&gt;.Any()).Returns(v =&gt; v + 1);\nimp.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 10)).Returns(100);\nimp.Increment(5).Returns(50); // implicit Arg&lt;int&gt;\n\n// Ref/Out/In\nimp.GenericAllRefKind&lt;int, string, double, bool, int&gt;(OutArg&lt;int&gt;.Any(), Arg&lt;string&gt;.Any(), Arg&lt;double&gt;.Any(), Arg&lt;bool[]&gt;.Any())\n   .Returns((out int o, ref string r, in double d, bool[] a) =&gt; { o = 5; return 99; })\n   .Callback((out int o, ref string r, in double d, bool[] a) =&gt; { o = 5; });\n\n// Async\nimp.GetNumberAsync().ReturnsAsync(42);\nimp.DoWorkAsync().Returns(Task.CompletedTask);\n\n// Throw\nimp.GetNumber().Throws&lt;InvalidOperationException&gt;();\n\n// Verify\nsvc.Increment(1);\nimp.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(1));\n</code></pre>"},{"location":"cheat-sheet/#properties","title":"Properties","text":"<pre><code>imp.Age.Getter().Returns(33);\nimp.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt; { });\nimp.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.Once());\n</code></pre>"},{"location":"cheat-sheet/#indexers","title":"Indexers","text":"<pre><code>imp[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\nimp[Arg&lt;int&gt;.Any()].Setter().Callback((i, v) =&gt; { });\n</code></pre>"},{"location":"cheat-sheet/#events","title":"Events","text":"<pre><code>EventHandler h = (s, e) =&gt; { };\nsvc.SomethingHappened += h;\nimp.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\nimp.SomethingHappened.Raise(this, EventArgs.Empty);\n</code></pre>"},{"location":"cheat-sheet/#base-implementation","title":"Base Implementation","text":"<pre><code>imp.DoWork(Arg&lt;int&gt;.Any()).UseBaseImplementation();\nimp.Age.Getter().UseBaseImplementation();\n</code></pre>"},{"location":"generics/","title":"Generics","text":"<p>Imposter supports generic methods, interfaces, classes, and fully open generic targets. Each closed generic combination gets its own setups and call history.</p> <p>Note</p> <p>Generic support applies across methods, properties, indexers, and events. Verification and argument matching are always scoped to the concrete type arguments used at call site.</p>"},{"location":"generics/#generic-methods","title":"Generic Methods","text":"<p>Generic methods (with their own <code>&lt;T&gt;</code> parameters) are treated like independent overloads per closed type argument combination. Each set of type arguments gets its own setup and verification.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\nusing Imposter.Tests.Features.OpenGenericImposter;\n\n[assembly: GenerateImposter(typeof(IHaveGenericMethods))]\n\nnamespace Imposter.Tests.Features.OpenGenericImposter\n{\n    public interface IHaveGenericMethods\n    {\n        TResult GetValue&lt;TResult&gt;();\n    }\n}\n</code></pre> <p>Example</p> C# 14C# 9-13 <pre><code>var imposter = IHaveGenericMethods.Imposter();\nimposter.GetValue&lt;int&gt;().Returns(5);\nimposter.GetValue&lt;string&gt;().Returns(\"value\");\n\nvar service = imposter.Instance();\nservice.GetValue&lt;int&gt;().ShouldBe(5);\nservice.GetValue&lt;string&gt;().ShouldBe(\"value\");\n</code></pre> <pre><code>var imposter = new IHaveGenericMethodsImposter();\nimposter.GetValue&lt;int&gt;().Returns(5);\nimposter.GetValue&lt;string&gt;().Returns(\"value\");\n\nvar service = imposter.Instance();\nservice.GetValue&lt;int&gt;().ShouldBe(5);\nservice.GetValue&lt;string&gt;().ShouldBe(\"value\");\n</code></pre>"},{"location":"generics/#generic-types","title":"Generic types","text":"<p>Generic interfaces like <code>IOpenGenericMethodTarget&lt;T&gt;</code> get a distinct imposter per closed type argument. Each closed generic interface tracks its own setups, calls, and verification.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\nusing Imposter.Tests.Features.OpenGenericImposter;\n\n[assembly: GenerateImposter(typeof(IOpenGenericMethodTarget&lt;&gt;))]\n\nnamespace Imposter.Tests.Features.OpenGenericImposter\n{\n    public interface IOpenGenericMethodTarget&lt;T&gt;\n    {\n        T GetNext();\n    }\n}\n</code></pre> <p>Example</p> C# 14C# 9-13 <pre><code>var imposter = IOpenGenericMethodTarget&lt;string&gt;.Imposter();\nimposter.GetNext().Returns(\"alpha\").Then().Returns(\"beta\");\n\nvar service = imposter.Instance();\nservice.GetNext().ShouldBe(\"alpha\");\nservice.GetNext().ShouldBe(\"beta\");\n</code></pre> <pre><code>var imposter = new IOpenGenericMethodTargetImposter&lt;string&gt;();\nimposter.GetNext().Returns(\"alpha\").Then().Returns(\"beta\");\n\nvar service = imposter.Instance();\nservice.GetNext().ShouldBe(\"alpha\");\nservice.GetNext().ShouldBe(\"beta\");\n</code></pre>"},{"location":"generics/#type-matching","title":"Type Matching","text":"<ul> <li>For input parameters, setups declared on a generic argument type (like <code>Animal</code>) match calls made with either that type itself or any derived type (like <code>Cat</code>);</li> </ul> <p>Example</p> <pre><code>public void GivenInputParameterSetup_WhenInvokedWithDerivedOrSameType_ShouldInvoke()\n{\n    var capturedAnimals = new List&lt;IAnimal&gt;();\n\n    _sut.GenericSingleParam&lt;Animal&gt;(Arg&lt;Animal&gt;.Any())\n        .Callback(animal =&gt;\n        {\n            capturedAnimals.Add(animal);\n        });\n\n    var animal = new Animal(\"mittens\");\n    _sut.Instance().GenericSingleParam(animal);\n\n    var cat = new Cat(\"mittens\");\n    _sut.Instance().GenericSingleParam(cat);\n\n    capturedAnimals.Count.ShouldBe(2);\n    capturedAnimals[0].ShouldBe(animal);\n    capturedAnimals[1].ShouldBe(cat);\n}\n</code></pre> <p>Example</p> <pre><code>public void GivenInputParameterSetup_WhenInvokedWithBase_ShouldNotInvoke()\n{\n    Cat? capturedAnimal = null;\n\n    _sut.GenericSingleParam&lt;Cat&gt;(Arg&lt;Cat&gt;.Any())\n        .Callback(animal =&gt;\n        {\n            capturedAnimal = animal;\n        });\n\n    var animal = new Animal(\"mittens\");\n    _sut.Instance().GenericSingleParam(animal);\n\n    capturedAnimal.ShouldBeNull();\n}\n</code></pre> <ul> <li>For output parameters, setups declared on a derived generic argument type (like <code>Cat</code>) can be invoked even when the method is called using a base type (like <code>IAnimal</code>) as the output parameter; the provided value is assigned and observed through the base-typed variable.</li> </ul> <p>Example</p> <pre><code>public void GivenOutputParameterSetupOnDerivedType_WhenMethodIsInvokedWithBaseType_ShouldInvoke()\n{\n    Cat? providedCat = null;\n\n    _sut.GenericSingleOutParam&lt;Cat&gt;(OutArg&lt;Cat&gt;.Any())\n        .Callback((out Cat value) =&gt;\n        {\n            providedCat = new Cat(\"mittens\");\n            value = providedCat;\n        });\n\n    _sut.Instance().GenericSingleOutParam&lt;IAnimal&gt;(out var impersonatedAnimal);\n\n    providedCat.ShouldNotBeNull();\n    impersonatedAnimal.ShouldBe(providedCat);\n}\n</code></pre> <p>Example</p> <pre><code>public void GivenOutputParameterSetupOnBase_WhenMethodIsInvokedWithDerivedType_ShouldNotInvoke()\n{\n    var baseCallbackInvoked = false;\n\n    _sut.GenericSingleOutParam&lt;IAnimal&gt;(OutArg&lt;IAnimal&gt;.Any())\n        .Callback((out IAnimal value) =&gt;\n        {\n            baseCallbackInvoked = true;\n            value = new Animal(\"base\");\n        });\n\n    _sut.Instance().GenericSingleOutParam&lt;Cat&gt;(out Cat? cat);\n\n    baseCallbackInvoked.ShouldBeFalse();\n    cat.ShouldBeNull();\n}\n</code></pre> <ul> <li>For ref parameters, setups are matched by the exact static generic argument: a setup declared on a base type (like <code>IAnimal</code>) does not match when the method is invoked with a <code>ref</code> argument of a derived type (like <code>Cat</code>), but a setup declared on <code>Dog</code> matches a <code>ref Dog</code> argument.</li> </ul> <p>Example</p> <pre><code>public void GivenRefParameterSetupOnBase_WhenInvokedWithDerivedType_ShouldNotInvoke()\n{\n    var animalCallback = false;\n\n    _sut.GenericSingleRefParam&lt;IAnimal&gt;(Arg&lt;IAnimal&gt;.Any())\n        .Callback((ref IAnimal _) =&gt; animalCallback = true);\n\n    var cat = new Cat(\"mittens\");\n    _sut.Instance().GenericSingleRefParam(ref cat);\n\n    animalCallback.ShouldBeFalse();\n}\n</code></pre> <p>Example</p> <pre><code>public void GivenRefParameterSetup_WhenInvokedWithSameType_ShouldInvoke()\n{\n    var dogCallbackInvoked = false;\n\n    _sut.GenericSingleRefParam&lt;Dog&gt;(Arg&lt;Dog&gt;.Any())\n        .Callback((ref Dog _) =&gt; dogCallbackInvoked = true);\n\n    var dog = new Dog(\"buddy\");\n    _sut.Instance().GenericSingleRefParam(ref dog);\n\n    dogCallbackInvoked.ShouldBeTrue();\n}\n</code></pre> <ul> <li>For generic return types, setups declared for a more specific derived type (like <code>Cat</code>) can be used when the method is invoked with a base return type (like <code>IAnimal</code>), but setups declared for a base type (like <code>IAnimal</code>) are not used when the method is invoked with a more specific derived return type (like <code>Cat</code>), so the call returns the default value instead.</li> </ul> <p>Example</p> <pre><code>public void GivenGenericReturnTypeSetupForDerived_WhenInvokedAsBase_ShouldReturnDerivedInstance()\n{\n    var providedCat = new Cat(\"mittens\");\n\n    _sut.GenericReturnType&lt;Cat&gt;().Returns(providedCat);\n\n    var impersonatedAnimal = _sut.Instance().GenericReturnType&lt;IAnimal&gt;();\n\n    impersonatedAnimal.ShouldBe(providedCat);\n}\n</code></pre> <p>Example</p> <pre><code>public void GivenGenericReturnTypeSetupForBase_WhenInvokedAsDerived_ShouldReturnDefault()\n{\n    _sut.GenericReturnType&lt;IAnimal&gt;().Returns(new Animal(\"base\"));\n\n    var result = _sut.Instance().GenericReturnType&lt;Cat&gt;();\n\n    result.ShouldBeNull();\n}\n</code></pre>"},{"location":"generics/#open-generics","title":"Open Generics","text":"<p>Open generics let you register a generic interface or class once (for example, <code>typeof(IAsyncObservable&lt;&gt;)</code>) and then create imposters for any concrete type you close it with at call site.</p> <p>From a behaviour point of view:</p> <ul> <li>Each closed generic target gets its own imposter type and its own call tracking. An <code>IAsyncObservable&lt;string&gt;</code> imposter and an <code>IAsyncObservable&lt;int&gt;</code> imposter never share setups or call history.</li> <li>Verification is always scoped to both the concrete type argument and the imposter instance. <code>stringImposter.OnNext(Arg&lt;string&gt;.Any()).Called(...)</code> only counts calls made through instances created from <code>stringImposter</code>; calls made through <code>intImposter.Instance()</code> do not contribute.</li> <li>This isolation applies across all members on the open generic type: methods, properties, indexers, and events on <code>IAsyncObservable&lt;string&gt;</code> are independent from the same members on <code>IAsyncObservable&lt;int&gt;</code> (or any other <code>T</code>).</li> <li>If you only invoke <code>OnNext</code> on the <code>int</code> stream and then try to verify <code>OnNext</code> on the <code>string</code> imposter, verification will fail because there are no matching calls for that closed type.</li> </ul> <p>Example</p> <pre><code>using Imposter.Abstractions;\nusing Imposter.Tests.Features.OpenGenericImposter;\n\n[assembly: GenerateImposter(typeof(IAsyncObservable&lt;&gt;))]\n\nnamespace Imposter.Tests.Features.OpenGenericImposter\n{\n    public interface IAsyncObservable&lt;T&gt;\n    {\n        void OnNext(T item);\n    }\n}\n</code></pre> <p>Example</p> C# 14C# 9-13 <pre><code>var stringImposter = IAsyncObservable&lt;string&gt;.Imposter();\nvar intImposter = IAsyncObservable&lt;int&gt;.Imposter();\n\nvar stringStream = stringImposter.Instance();\nvar intStream = intImposter.Instance();\n\nstringStream.OnNext(\"payload\");\nstringStream.OnNext(\"another\");\nintStream.OnNext(42);\n\nstringImposter.OnNext(Arg&lt;string&gt;.Any()).Called(Count.Exactly(2));\nintImposter.OnNext(Arg&lt;int&gt;.Any()).Called(Count.Once());\n</code></pre> <pre><code>var stringImposter = new IAsyncObservableImposter&lt;string&gt;();\nvar intImposter = new IAsyncObservableImposter&lt;int&gt;();\n\nvar stringStream = stringImposter.Instance();\nvar intStream = intImposter.Instance();\n\nstringStream.OnNext(\"payload\");\nstringStream.OnNext(\"another\");\nintStream.OnNext(42);\n\nstringImposter.OnNext(Arg&lt;string&gt;.Any()).Called(Count.Exactly(2));\nintImposter.OnNext(Arg&lt;int&gt;.Any()).Called(Count.Once());\n</code></pre>"},{"location":"implicit-vs-explicit/","title":"Implicit vs Explicit Modes","text":"<p>How <code>ImposterMode</code> affects methods, properties, and indexers when no setup exists.</p>"},{"location":"implicit-vs-explicit/#methods","title":"Methods","text":"<p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(IMyService))]\n\npublic interface IMyService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre>"},{"location":"implicit-vs-explicit/#implicit-mode-methods","title":"Implicit mode (methods)","text":"<p>Methods without setups are implicitly stubbed and return <code>default(T)</code>.</p> <p>Example</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar service = imposter.Instance();\n\n// Method without a setup =&gt; default(int) == 0\nint n = service.GetNumber(); // 0\n\n// Add a setup and the call returns your value\nimposter.GetNumber().Returns(42);\nservice.GetNumber(); // 42\n\n// Async methods\nimposter.GetNumberAsync().ReturnsAsync(7);\nvar v = await service.GetNumberAsync(); // 7\n</code></pre>"},{"location":"implicit-vs-explicit/#explicit-mode-methods","title":"Explicit mode (methods)","text":"<p>Missing setups throw an exception so unintended calls are caught.</p> <p>Example</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Explicit);\nvar service = imposter.Instance();\n\n// No setup -&gt; throws MissingImposterException\nShould.Throw&lt;MissingImposterException&gt;(() =&gt; service.GetNumber());\n\n// Add a setup -&gt; call succeeds\nimposter.GetNumber().Returns(42);\nservice.GetNumber(); // 42\n</code></pre> <p>Pro tip</p> <p>Default to <code>Explicit</code> in unit tests to catch missing setups early. Use <code>Implicit</code> in spike/prototyping code where default results are acceptable.</p>"},{"location":"implicit-vs-explicit/#properties","title":"Properties","text":"<p>In Implicit mode, property getters without setups return <code>default(T)</code> and setters do nothing. In Explicit mode, missing setups throw <code>MissingImposterException</code>.</p> <p>Example</p> <pre><code>var imposter = new IPropertySetupSutImposter(ImposterMode.Implicit);\nvar sut = imposter.Instance();\n\n// No getter setup =&gt; default(int) == 0\nint n = sut.Age; // 0\n\n// No setter setup =&gt; call is ignored\nsut.Age = 10;\n</code></pre> <p>Example</p> <pre><code>var imposter = new IPropertySetupSutImposter(ImposterMode.Explicit);\nvar sut = imposter.Instance();\n\n// No getter setup -&gt; MissingImposterException\n// sut.Age; // throws\n\n// No setter setup -&gt; MissingImposterException\n// sut.Age = 10; // throws\n</code></pre>"},{"location":"implicit-vs-explicit/#indexers","title":"Indexers","text":"<p>Indexers follow the same rules: Implicit mode returns defaults / does nothing; Explicit mode throws when no setup matches.</p> <p>Example</p> <pre><code>var imposter = new IIndexerSetupSutImposter(ImposterMode.Implicit);\nvar sut = imposter.Instance();\n\n// No setup =&gt; default(int) == 0\nint value = sut[1, \"key\"]; // 0\n\n// Setter without setup is ignored\nsut[1, \"key\"] = 10;\n</code></pre> <p>Example</p> <pre><code>var imposter = new IIndexerSetupSutImposter(ImposterMode.Explicit);\nvar sut = imposter.Instance();\n\n// No getter setup -&gt; MissingImposterException\n// var value = sut[1, \"missing\"]; // throws\n\n// No setter setup -&gt; MissingImposterException\n// sut[1, \"missing\"] = 10; // throws\n</code></pre>"},{"location":"key-api-reference/","title":"Key API Reference","text":"<p>A compact list of the core types and fluent members you\u2019ll use most. This is not a full API surface \u2014 just the names and signatures you need to get productive.</p>"},{"location":"key-api-reference/#attribute","title":"Attribute","text":"<ul> <li><code>GenerateImposterAttribute</code></li> <li>Usage: <code>[assembly: Imposter.Abstractions.GenerateImposter(typeof(TTarget), bool putInTheSameNamespace = true)]</code></li> <li>Parameters:<ul> <li><code>Type type</code> \u2014 target interface or class</li> <li><code>bool putInTheSameNamespace = true</code> - try to place the generated imposter in the target's namespace</li> </ul> </li> </ul> <p>Pro tip</p> <p>Add the attribute at the assembly level in a single file to keep generation centralized and easy to audit.</p>"},{"location":"key-api-reference/#argument-matchers","title":"Argument Matchers","text":"<ul> <li><code>Arg&lt;T&gt;</code></li> <li><code>static Arg&lt;T&gt; Is(Func&lt;T, bool&gt; predicate)</code></li> <li><code>static Arg&lt;T&gt; Is(T? value)</code></li> <li><code>static Arg&lt;T&gt; Is(T? value, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsNot(Func&lt;T, bool&gt; predicate)</code></li> <li><code>static Arg&lt;T&gt; IsNot(T? value)</code></li> <li><code>static Arg&lt;T&gt; IsNot(T? value, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsIn(IEnumerable&lt;T&gt; values)</code></li> <li><code>static Arg&lt;T&gt; IsIn(IEnumerable&lt;T&gt; values, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsNotIn(IEnumerable&lt;T&gt; values)</code></li> <li><code>static Arg&lt;T&gt; IsNotIn(IEnumerable&lt;T&gt; values, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsDefault()</code></li> <li><code>static Arg&lt;T&gt; Any()</code></li> <li> <p><code>static implicit operator Arg&lt;T&gt;(T value)</code></p> </li> <li> <p><code>OutArg&lt;T&gt;</code></p> </li> <li><code>static OutArg&lt;T&gt; Any()</code> \u2014 wildcard for <code>out</code> parameters</li> </ul>"},{"location":"key-api-reference/#verification-counts","title":"Verification Counts","text":"<ul> <li><code>Count</code></li> <li><code>static Count Exactly(int count)</code></li> <li><code>static Count AtLeast(int count)</code></li> <li><code>static Count AtMost(int count)</code></li> <li><code>static Count Never()</code></li> <li><code>static Count Once()</code></li> <li><code>static readonly Count Any</code></li> </ul>"},{"location":"key-api-reference/#imposter-mode","title":"Imposter Mode","text":"<ul> <li><code>ImposterMode</code></li> <li><code>Implicit</code> \u2014 missing setups return defaults (loose)</li> <li><code>Explicit</code> \u2014 missing setups throw <code>MissingImposterException</code> (strict)</li> </ul>"},{"location":"key-api-reference/#method-setups-generated","title":"Method Setups (generated)","text":"<ul> <li>Typical fluent members on a method setup builder:</li> <li><code>Returns(TResult value)</code></li> <li><code>Returns(Func&lt;TResult&gt; factory)</code></li> <li><code>Returns(Func&lt;...parameters..., TResult&gt; factory)</code> \u2014 delegate receives in/ref/out/in params</li> <li><code>ReturnsAsync(TResult value)</code></li> <li><code>ReturnsAsync(Func&lt;Task&lt;TResult&gt;&gt; factory)</code></li> <li><code>Throws(Exception ex)</code></li> <li><code>Throws&lt;TException&gt;()</code></li> <li><code>Callback(Action action)</code> / <code>Callback(Action&lt;...parameters...&gt; action)</code></li> <li><code>Then()</code> \u2014 chain next behavior (return/throw/etc.) for subsequent matching calls</li> <li><code>Called(Count count)</code> \u2014 verify invocation frequency</li> </ul>"},{"location":"key-api-reference/#property-setups-generated","title":"Property Setups (generated)","text":"<ul> <li>Getter: <code>imposter.Property.Getter()</code> \u2192 supports <code>Returns(...)</code>, <code>Throws(...)</code>, <code>Callback(...)</code>, <code>Then()</code>, <code>Called(Count)</code></li> <li>Setter: <code>imposter.Property.Setter(Arg&lt;T&gt; valueMatcher)</code> \u2192 supports <code>Callback(...)</code>, <code>Called(Count)</code></li> <li>Base implementation: <code>UseBaseImplementation()</code> (when applicable for classes)</li> </ul> <p>Pro tip</p> <p>Do not edit generated <code>.g.cs</code> files. Change behavior via setups or generator inputs, then rebuild.</p>"},{"location":"key-api-reference/#indexer-setups-generated","title":"Indexer Setups (generated)","text":"<ul> <li>Indexer access: <code>imposter[Arg&lt;T1&gt;..., Arg&lt;TN&gt;...]</code></li> <li>Getter: <code>.Getter()</code> \u2192 <code>Returns(...)</code>, <code>Throws(...)</code>, <code>Callback(...)</code>, <code>Then()</code>, <code>Called(Count)</code></li> <li>Setter: <code>.Setter()</code> / <code>.Setter(Arg&lt;TValue&gt; valueMatcher)</code> \u2192 <code>Callback(...)</code>, <code>Called(Count)</code></li> <li>Base implementation: <code>UseBaseImplementation()</code></li> </ul>"},{"location":"key-api-reference/#event-helpers-generated","title":"Event Helpers (generated)","text":"<ul> <li>Raise: <code>imposter.Event.Raise(object? sender, EventArgs args)</code> (or concrete event args type)</li> <li>Verify:</li> <li><code>imposter.Event.Subscribed(Arg&lt;Delegate&gt;.Is(handler), Count count)</code></li> <li><code>imposter.Event.HandlerInvoked(Arg&lt;Delegate&gt;.Is(handler), Count count)</code></li> </ul> <p>See also: Cheat Sheet and Limitations.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>Imposter keeps the source generator and runtime focused on common impersonation scenarios. This comes with a few intentional limitations.</p>"},{"location":"limitations/#language-and-tooling","title":"Language and tooling","text":"<ul> <li>Minimum supported C# version is 9.0.</li> <li>Only Roslyn-based C# projects are supported (no Visual Basic or F#).</li> </ul>"},{"location":"limitations/#class-targets","title":"Class targets","text":"<ul> <li>Only non-sealed classes can be impersonated.</li> <li>Only virtual or abstract members can be impersonated on class imposters.</li> <li><code>UseBaseImplementation()</code> applies only to non-abstract, virtual class members and is not available for interfaces.</li> </ul>"},{"location":"limitations/#async-behavior","title":"Async behavior","text":"<ul> <li>Async methods without setup return <code>default</code>, which for <code>Task</code> is <code>null</code>.</li> <li>Sequenced async outcomes are consumed in order; when a sequence is exhausted, the last outcome is repeated (where applicable).</li> </ul>"},{"location":"limitations/#generated-code","title":"Generated code","text":"<ul> <li>Generated <code>.g.cs</code> files are implementation details and should not be edited directly; customize behavior via setups or by changing generator inputs.</li> </ul> <p>Next steps</p> <ul> <li>Getting Started</li> <li>Key API Reference</li> <li>Base Implementation</li> <li>Cheat Sheet</li> </ul>"},{"location":"verification/","title":"Verification","text":"<p>How <code>Count</code> works when verifying calls.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IVerifyService))]\n\npublic interface IVerifyService\n{\n    void Increment(int v);\n    int Combine(int a, int b);\n}\n</code></pre>"},{"location":"verification/#count-basics","title":"Count basics","text":"<p><code>Count</code> describes how many matching invocations are expected when you call <code>.Called(Count ...)</code>.</p> <p>Example</p> <pre><code>var imposter = new IVerifyServiceImposter();\nvar service = imposter.Instance();\n\nservice.Increment(1);\nservice.Increment(2);\nservice.Increment(2);\n\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(3));\nimposter.Increment(2).Called(Count.Exactly(2));\nimposter.Increment(1).Called(Count.Once());\nimposter.Increment(999).Called(Count.Never());\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.Any);\n</code></pre>"},{"location":"verification/#available-counts","title":"Available counts","text":"<ul> <li><code>Count.Exactly(n)</code> \u2014 require exactly <code>n</code> matching calls.</li> <li><code>Count.AtLeast(n)</code> \u2014 require <code>&gt;= n</code> matching calls.</li> <li><code>Count.AtMost(n)</code> \u2014 require <code>&lt;= n</code> matching calls.</li> <li><code>Count.Once()</code> \u2014 shorthand for <code>Count.Exactly(1)</code>.</li> <li><code>Count.Never()</code> \u2014 shorthand for <code>Count.Exactly(0)</code>.</li> <li><code>Count.Any</code> \u2014 no constraint; always succeeds.</li> </ul> <p>Counts always apply to matching invocations only (based on your <code>Arg&lt;T&gt;</code> / <code>OutArg&lt;T&gt;</code> matchers).</p>"},{"location":"verification/#where-to-use-count","title":"Where to use Count","text":"<ul> <li>Methods:</li> <li><code>imposter.Method(...).Called(Count.Exactly(n));</code></li> <li>Properties:</li> <li><code>imposter.Property.Getter().Called(Count.AtLeast(1));</code></li> <li><code>imposter.Property.Setter(Arg&lt;T&gt;.Any()).Called(Count.Once());</code></li> <li>Indexers:</li> <li><code>imposter[Arg&lt;int&gt;.Is(i =&gt; i &gt; 0)].Getter().Called(Count.Exactly(1));</code></li> <li>Events:</li> <li><code>imposter.Event.Subscribed(Arg&lt;Delegate&gt;.Is(handler), Count.Once());</code></li> <li><code>imposter.Event.HandlerInvoked(Arg&lt;Delegate&gt;.Is(handler), Count.AtLeast(1));</code></li> </ul> <p>See also:</p> <ul> <li>Methods \u25b8 Verification \u2014 method-focused examples.</li> <li>Key API Reference \u2014 quick signature list.</li> </ul>"},{"location":"events/","title":"Event Impersonation","text":""},{"location":"events/#creating-an-imposter","title":"Creating an imposter","text":"<p>Define the target interface and enable generation:</p> <p>Example</p> <pre><code>using System;\nusing System.Threading.Tasks;\nusing Imposter.Abstractions;\nusing Imposter.Tests.Features.EventImposter;\n\n[assembly: GenerateImposter(typeof(IEventSetupSut))]\n\npublic interface IEventSetupSut\n{\n    event EventHandler SomethingHappened;\n\n    event Func&lt;object?, EventArgs, Task&gt;? AsyncSomethingHappened;\n\n    event Func&lt;object?, EventArgs, ValueTask&gt;? ValueTaskSomethingHappened;\n\n    event AsyncEventHandler&lt;EventArgs&gt;? CustomAsyncSomethingHappened;\n}\n\npublic delegate Task AsyncEventHandler&lt;in TEventArgs&gt;(object? sender, TEventArgs args)\n    where TEventArgs : EventArgs;\n</code></pre>"},{"location":"events/#subscribeunsubscribe-verification","title":"Subscribe/Unsubscribe Verification","text":"<p>Example</p> <pre><code>EventHandler h = (s, e) =&gt; { };\n\nservice.SomethingHappened += h;\nservice.SomethingHappened -= h;\n\nimposter.SomethingHappened.Subscribed(h, Count.Once());\nimposter.SomethingHappened.Unsubscribed(h, Count.Once());\n</code></pre>"},{"location":"events/#raise-an-event","title":"Raise an event","text":"<p>Example</p> <pre><code>// Raise in-order for current subscribers\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\n</code></pre> <p>Note</p> <ul> <li><code>Raise(sender, args)</code> notifies the handlers currently subscribed at the time of the call, in subscription order.</li> <li>If no one is subscribed, <code>Raise</code> is a no-op.</li> <li>Exceptions thrown by a handler bubble up and stop further handlers unless your SUT or test catches them (see Event Exceptions).</li> </ul>"},{"location":"events/#interceptors-and-invocation-counts","title":"Interceptors and Invocation Counts","text":"<p>Example</p> <pre><code>// Observe subscriptions/unsubscriptions\nimposter.SomethingHappened.OnSubscribe(handler =&gt; { /* inspect */ });\nimposter.SomethingHappened.OnUnsubscribe(handler =&gt; { /* inspect */ });\n\n// Verify handler invocation count\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Exactly(2));\n</code></pre>"},{"location":"events/exceptions/","title":"Event Exceptions","text":"<p>Understand how exceptions interact with the event pipeline and how to assert failure paths.</p>"},{"location":"events/exceptions/#no-subscribers","title":"No subscribers","text":"<p>Raising with no subscribers is a no-op:</p> <p>Example</p> <pre><code>imposter.SomethingHappened.Raise(this, EventArgs.Empty); // does nothing\n</code></pre>"},{"location":"events/exceptions/#subscriber-throws","title":"Subscriber throws","text":"<p>If a subscribed handler throws, the exception bubbles up and subsequent handlers are not invoked unless the exception is caught by your code under test:</p> <p>Example</p> <pre><code>EventHandler boom = (s, e) =&gt; throw new InvalidOperationException(\"boom\");\nservice.SomethingHappened += boom;\n\nAssert.Throws&lt;InvalidOperationException&gt;(() =&gt; imposter.SomethingHappened.Raise(this, EventArgs.Empty));\n</code></pre> <p>If you want to continue invoking the remaining handlers even if one throws, catch exceptions in your code under test and make that behavior explicit.</p>"},{"location":"events/protected-members/","title":"Protected Events","text":"<p>Configure protected virtual events on class targets and interact through public wrappers.</p>"},{"location":"events/protected-members/#subscriberaise-via-wrapper","title":"Subscribe/Raise via wrapper","text":"<p>Example</p> <pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual event EventHandler? ProtectedChanged;\n\n    public virtual void Subscribe(EventHandler h) =&gt; ProtectedChanged += h;\n    public virtual void Unsubscribe(EventHandler h) =&gt; ProtectedChanged -= h;\n}\n\nvar imp = new MyServiceImposter();\nvar svc = imp.Instance();\n\n// Forward wrapper methods to base accessors\nimp.Subscribe(Arg&lt;EventHandler&gt;.Any()).UseBaseImplementation();\nimp.Unsubscribe(Arg&lt;EventHandler&gt;.Any()).UseBaseImplementation();\n\n// Subscribe through the wrapper, then raise protected event\nvar called = false;\nsvc.Subscribe((s, e) =&gt; called = true);\nimp.ProtectedChanged.Raise(svc, EventArgs.Empty);\n// called == true\n</code></pre>"},{"location":"events/verification/","title":"Event Verification","text":"<p>Verify handler subscriptions and invocations.</p>"},{"location":"events/verification/#subscribed-verification","title":"Subscribed verification","text":"<p>Example</p> <pre><code>EventHandler h = (s, e) =&gt; { };\n\nservice.SomethingHappened += h;\nservice.SomethingHappened += h;\n\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Exactly(2));\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.AtLeast(1));\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.AtMost(2));\n</code></pre>"},{"location":"events/verification/#handlerinvoked-verification","title":"HandlerInvoked verification","text":"<p>Example</p> <pre><code>int count = 0;\nEventHandler h = (s, e) =&gt; count++;\nservice.SomethingHappened += h;\n\nimposter.SomethingHappened.Raise(this, EventArgs.Empty).Raise(this, EventArgs.Empty);\n\ncount.ShouldBe(2);\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Exactly(2));\n</code></pre>"},{"location":"events/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown with a message that clearly reports expected vs actual counts.</p>"},{"location":"indexers/","title":"Indexer Impersonation","text":""},{"location":"indexers/#creating-an-imposter","title":"Creating an imposter","text":"<p>Use the generated imposter type for your indexer-bearing interface or class and obtain the configured instance:</p> <p>Example</p> <pre><code>[assembly: GenerateImposter(typeof(IMyServiceSut))]\n\npublic interface IMyServiceSut\n{\n    int this[int key1] { get; set; }\n}\n</code></pre>"},{"location":"indexers/#getter","title":"Getter","text":"<p>Example</p> <pre><code>var imposter = IMyServiceSut.Imposter();\nimposter[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\n\nvar service = imposter.Instance();\nvar value = service[123]; // 10\n</code></pre>"},{"location":"indexers/#setter","title":"Setter","text":"<p>Example</p> <pre><code>// Observe writes\nimposter[Arg&lt;int&gt;.Any()].Setter().Callback((key, value) =&gt; \n        { \n            // value is 50\n        });\n\nvar service = imposter.Instance();\nservice[42] = 50;\n</code></pre>"},{"location":"indexers/protected-members/","title":"Protected Indexers","text":"<p>Virtual and abstract protected indexers can be configured on the imposter.</p>"},{"location":"indexers/protected-members/#gettersetter-with-wrapper","title":"Getter/Setter with wrapper","text":"<p>Example</p> <pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual int this[int index]\n    {\n        get =&gt; index;\n        set { /* track */ }\n    }\n\n}\n\nvar imposter = new MyServiceImposter();\nimp[Arg&lt;int&gt;.Any()].Getter().Returns(i =&gt; i * 10);\nimp[Arg&lt;int&gt;.Any()].Getter().Callback((key, value) =&gt; { .. });\n</code></pre>"},{"location":"indexers/throwing/","title":"Indexer Throwing","text":"<p>In Explicit mode or when desired, configure indexer getters to throw. For setters, prefer verification via <code>Called(Count...)</code> and callbacks, optionally throwing from callbacks when validation fails.</p>"},{"location":"indexers/throwing/#getter-throwing","title":"Getter throwing","text":"<p>Example</p> <pre><code>imposter[Arg&lt;int&gt;.Any(), Arg&lt;string&gt;.Any(), Arg&lt;object&gt;.Any()]\n    .Getter()\n    .Throws&lt;InvalidOperationException&gt;();\n\nvar service = imposter.Instance();\n\n// Read throws the configured exception\nShould.Throw&lt;InvalidOperationException&gt;(() =&gt; _ = service[3, \"err\", new object()]);\n</code></pre>"},{"location":"indexers/throwing/#setter-validation-with-throwing-callbacks","title":"Setter validation with throwing callbacks","text":"<p>Example</p> <pre><code>imposter[Arg&lt;int&gt;.Any()].Setter().Callback((key, value)\n        =&gt; throw new InvalidOperationException(\"Callback error\"));\nShould.Throw&lt;InvalidOperationException&gt;(() =&gt; service[42] = 10);\n</code></pre>"},{"location":"indexers/verification/","title":"Indexer Verification","text":""},{"location":"indexers/verification/#setter-verification","title":"Setter verification","text":"<p>Example</p> <pre><code>service[1] = 10;\nservice[2] = 20;\n\nimposter[Arg&lt;int&gt;.Any()].Setter().Called(Count.AtLeast(2));\nimposter[Arg&lt;int&gt;.Is(2)].Setter().Called(Count.Once());\n</code></pre>"},{"location":"indexers/verification/#getter-verification","title":"Getter verification","text":"<p>Example</p> <pre><code>var _ = service[1];\nimposter[Arg&lt;int&gt;.Any()].Getter().Called(Count.Once());\n</code></pre>"},{"location":"indexers/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown with the message:</p> <p>Example</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\n</code></pre> <p>Examples:</p> <p>Example</p> <pre><code>// Setter expected once for index 2, but no matching write occurred\nimposter[Arg&lt;int&gt;.Is(2)].Setter().Called(Count.Once());\n// throws: \"Invocation was expected to be performed exactly 1 time(s) but instead was performed 0 times.\"\n\n// Getter expected at least 2 reads, but only 1\nvar _ = service[1];\nimposter[Arg&lt;int&gt;.Any()].Getter().Called(Count.AtLeast(2));\n// throws: \"Invocation was expected to be performed at least 2 time(s) but instead was performed 1 times.\"\n</code></pre>"},{"location":"methods/","title":"Overview","text":""},{"location":"methods/#creating-an-imposter","title":"Creating an imposter","text":"<p>Define the target interface and enable generation:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IQuickStartService))]\n\npublic interface IQuickStartService\n{\n    int GetNumber();\n\n    int Increment(int v);\n\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n\n    System.Threading.Tasks.Task DoWorkAsync();\n\n    int Combine(int a, int b);\n\n    int VirtualCompute(int v);\n}\n</code></pre>"},{"location":"methods/#setup-return-values","title":"Setup Return values","text":"<ul> <li>Return a constant value:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Returns(1);\n\nimposter.Instance().GetNumber(); // returns 1\n</code></pre> <ul> <li>Return via a delegate (captures inputs):</li> </ul> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any()).Returns(v =&gt; v + 2);\n\nimposter.Instance().Increment(10); // returns 12;\n</code></pre> <ul> <li>Sequence multiple outcomes with <code>Then()</code>:</li> </ul> <p>Example</p> <pre><code>imposter\n     .Increment(Arg&lt;int&gt;.Any())\n     .Returns(v =&gt; v + 2)\n     .Then()\n     .Returns(v =&gt; v + 3)\n     .Then()\n     .Returns(v =&gt; v + 4);\n\n imposter.Instance().Increment(10); // returns 12\n imposter.Instance().Increment(10); // returns 13\n imposter.Instance().Increment(10); // returns 14\n\n // sequence is exhausetd, last outcome repeats\n imposter.Instance().Increment(10); // returns 14\n</code></pre> <p>Note</p> <ul> <li>Use <code>Then()</code> to set up sequence</li> <li>After a sequence is exhausted, the last outcome repeats</li> </ul>"},{"location":"methods/#async-methods","title":"Async Methods","text":"<p>With async methods, imposter provides some handy methods to simplify setup:</p> <ul> <li>Task and ValueTask methods: <p>Example</p> <pre><code>imposter.GetNumberAsync().ReturnsAsync(42);\n\nawait imposter.Instance().GetNumberAsync(); // returns 41\n</code></pre> <ul> <li>Task-returning (no result):</li> </ul> <p>Example</p> <pre><code>imposter.DoWorkAsync().Returns(Task.CompletedTask);\n</code></pre> <ul> <li>Sequencing remains the same:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumberAsync()\n    .ReturnsAsync(1)\n    .Then().Returns(() =&gt; Task.FromResult(2));\n</code></pre> <p>Pro tip</p> <p>Prefer <code>ReturnsAsync</code> for Task/ValueTask methods. It reads cleaner and avoids accidental sync-over-async in factories.</p> <p>Warning</p> <p>Async methods without setup return <code>default</code>, which in case of <code>Task</code> is <code>null</code>.</p>"},{"location":"methods/#refoutin-parameters","title":"Ref/Out/In Parameters","text":"<p>Use <code>OutArg&lt;T&gt;.Any()</code> to match <code>out</code> parameters; <code>Arg&lt;T&gt;</code> for <code>ref</code> and <code>in</code>.</p> <p>Returns and callbacks can specify <code>out/ref/in</code> in the delegate signature:</p> <p>Example</p> <pre><code>imposter.GenericAllRefKind&lt;int, string, double, bool, int&gt;(\n        OutArg&lt;int&gt;.Any(),\n        Arg&lt;string&gt;.Any(),\n        Arg&lt;double&gt;.Any(),\n        Arg&lt;bool[]&gt;.Any())\n    .Returns((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; return 99; })\n    .Callback((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; });\n</code></pre>"},{"location":"methods/#base-implementation-class-targets","title":"Base Implementation (Class Targets)","text":"<p>Info</p> <p><code>UseBaseImplementation()</code> applies only to non-abstract, virtual class members. It is not available for interfaces. See the dedicated page: Base Implementation.</p>"},{"location":"methods/#verification","title":"Verification","text":"<p>Use <code>Called(Count.*)</code> on the method to assert invocation counts:</p> <p>Example</p> <pre><code>// After calling service methods\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Increment(2).Called(Count.Once());\n</code></pre> <p>See more examples on GitHub. <code>Count</code> options: - <code>Exactly(n)</code>, <code>AtLeast(n)</code>, <code>AtMost(n)</code>, <code>Once()</code>, <code>Never()</code>, <code>Any</code></p> <p>If verification fails, a <code>VerificationFailedException</code> is thrown with a clear message.</p> <p>Pro tip</p> <p>Place verification at the end of the test. Verify the broad call first (e.g., <code>Any()</code>), then the specific one to keep failure messages focused.</p> <p>Next steps</p> <ul> <li>Deep dives for methods:</li> <li>Sequential Returns</li> <li>Throwing Exceptions</li> <li>Verification</li> <li>Callbacks</li> <li>Base Implementation</li> <li>Protected Methods</li> <li>Imposter Modes</li> </ul>"},{"location":"methods/#concurrency-notes","title":"Concurrency Notes","text":"<p>Sequenced outcomes are consumed in order under concurrency; the implementation avoids races that would otherwise reorder or drop planned outcomes. If a sequence is exhausted, the last outcome is repeated (when applicable) or default behavior applies.</p>"},{"location":"methods/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Repeating <code>Returns</code> or <code>Throws</code> without <code>Then()</code> is invalid.</li> <li>In <code>Explicit</code> mode, missing setups throw <code>MissingImposterException</code>.</li> <li>Ensure <code>OutArg&lt;T&gt;.Any()</code> is used for <code>out</code> parameters; use <code>Arg&lt;T&gt;</code> for <code>ref</code>/<code>in</code>.</li> </ul>"},{"location":"methods/callbacks/","title":"Method Callbacks","text":"<p>Callbacks run after the arranged result (or after the default result in Implicit mode when no <code>Returns</code> is provided).</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.ICallbackService))]\n\npublic interface ICallbackService\n{\n    int GetNumber();\n    int Increment(int v);\n    int GenericAllRefKind(out int o, ref string r, in double d, bool[] args);\n}\n</code></pre>"},{"location":"methods/callbacks/#ordering-relative-to-results","title":"Ordering relative to results","text":"<p>Example</p> <pre><code>var stages = new List&lt;string&gt;();\n\nimposter.GetNumber()\n    .Returns(() =&gt; { stages.Add(\"return\"); return 42; })\n    .Callback(() =&gt; stages.Add(\"first\"))\n    .Callback(() =&gt; stages.Add(\"second\"));\n\nservice.GetNumber();\n// stages == [\"return\", \"first\", \"second\"]\n</code></pre>"},{"location":"methods/callbacks/#parameterized-callbacks","title":"Parameterized callbacks","text":"<p>Capture input arguments in a callback:</p> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any()).Callback(v =&gt; Logger.Log($\"value: {v}\"));\n</code></pre>"},{"location":"methods/callbacks/#refoutin-with-callbacks","title":"Ref/out/in with callbacks","text":"<p>Callbacks can work with <code>out</code>, <code>ref</code>, and <code>in</code> parameters. Use <code>OutArg&lt;T&gt;.Any()</code> to match <code>out</code> parameters in the setup signature.</p> <p>Example</p> <pre><code>imposter.GenericAllRefKind&lt;int, string, double, bool, int&gt;(\n        OutArg&lt;int&gt;.Any(),\n        Arg&lt;string&gt;.Any(),\n        Arg&lt;double&gt;.Any(),\n        Arg&lt;bool[]&gt;.Any())\n    .Returns((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; return 99; })\n    .Callback((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; /* side-effects */ });\n</code></pre>"},{"location":"methods/callbacks/#sequence-local-callbacks","title":"Sequence-local callbacks","text":"<p>Callbacks are scoped to the sequence step they\u2019re defined on. Use <code>Then()</code> to create a new step with independent callbacks.</p> <p>Example</p> <pre><code>var seen = new List&lt;string&gt;();\n\nimposter.Increment(Arg&lt;int&gt;.Any())\n    .Returns(_ =&gt; 10)\n    .Callback(_ =&gt; seen.Add(\"first\"))\n    .Then()\n    .Returns(_ =&gt; 20)\n    .Callback(_ =&gt; seen.Add(\"second\"));\n\nservice.Increment(1); // adds \"first\"\nservice.Increment(2); // adds \"second\"\n</code></pre>"},{"location":"methods/callbacks/#callbacks-that-throw","title":"Callbacks that throw","text":"<p>If a callback throws, the exception is propagated to the caller after the result has been produced.</p> <p>Example</p> <pre><code>// See more examples in repo tests\nimposter.GetNumber()\n    .Returns(1)\n    .Callback(() =&gt; throw new InvalidOperationException(\"boom\"));\n\n// service.GetNumber() returns 1, then throws InvalidOperationException\n</code></pre>"},{"location":"methods/protected-members/","title":"Protected Methods","text":"<p>Overrideable protected members of the class can be impersonated just like other overridable class members.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.Protected.MyService))]\n\nnamespace Imposter.Tests.Docs.Methods.Protected\n{\n    public class MyService\n    {\n        protected virtual int ProtectedAdd(int value) =&gt; value * 2;\n        public virtual int InvokeProtected(int value) =&gt; ProtectedAdd(value);\n    }\n}\n</code></pre>"},{"location":"methods/protected-members/#example","title":"Example","text":"<p>Example</p> <pre><code>// Class target with a protected virtual method and a public wrapper that calls it\n[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual int ProtectedAdd(int value) =&gt; value * 2;\n    public virtual int InvokeProtected(int value) =&gt; ProtectedAdd(value);\n}\n\nvar imposter = new MyServiceImposter();\n\n// Arrange the protected method directly on the imposter\nimposter.ProtectedAdd(Arg&lt;int&gt;.Is(5)).Returns(42);\n\nvar service = imposter.Instance();\nservice.InvokeProtected(5).ShouldBe(42);\n</code></pre> <p>See more examples on GitHub.</p>"},{"location":"methods/sequential-returns/","title":"Sequential Returns","text":"<p>Imposter supports sequencing multiple outcomes for the same method using <code>Then()</code>. This is useful for modeling stateful behavior across repeated calls.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.ISeqService))]\n\npublic interface ISeqService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre>"},{"location":"methods/sequential-returns/#basic-sequencing","title":"Basic sequencing","text":"<p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Returns(2)\n    .Then().Returns(3);\n\nservice.GetNumber(); // 1\nservice.GetNumber(); // 2\nservice.GetNumber(); // 3\n</code></pre>"},{"location":"methods/sequential-returns/#interleaving-exceptions","title":"Interleaving exceptions","text":"<p>You can interleave <code>Throws</code> within a sequence. Separate each step with <code>Then()</code>.</p> <p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Throws&lt;InvalidOperationException&gt;()\n    .Then().Returns(2);\n\nservice.GetNumber(); // 1\nservice.GetNumber(); // throws InvalidOperationException\nservice.GetNumber(); // 2\n</code></pre> <p>Pro tip</p> <ul> <li>Always use <code>Then()</code> between distinct outcomes.</li> <li>Repeating <code>Returns</code> (or <code>Throws</code>) without <code>Then()</code> is invalid.</li> <li>You can mix <code>Returns</code>, <code>ReturnsAsync</code>, <code>Throws</code>, and <code>UseBaseImplementation()</code> across steps for class targets.</li> </ul>"},{"location":"methods/sequential-returns/#concurrency-note","title":"Concurrency note","text":"<p>Under concurrent calls, outcomes are consumed in order. When a sequence is exhausted, behavior falls back to the last applicable outcome or to default behavior (depending on the target and mode).</p>"},{"location":"methods/throwing/","title":"Throwing Exceptions","text":"<p>Arrange methods to throw exceptions instead of returning values. This is useful for testing exception paths and retry logic.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IThrowService))]\n\npublic interface IThrowService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre>"},{"location":"methods/throwing/#ways-to-throw","title":"Ways to throw","text":"<ul> <li>Generic type:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws&lt;InvalidOperationException&gt;();\n\nservice.GetNumber(); // throws InvalidOperationException\n</code></pre> <ul> <li>Specific instance:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws(new Exception(\"boom\"));\n\nservice.GetNumber(); // throws Exception(\"boom\")\n</code></pre> <ul> <li>Factory delegate:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws(() =&gt; new Exception(\"deferred\"));\n\nservice.GetNumber(); // throws Exception(\"deferred\")\n</code></pre>"},{"location":"methods/throwing/#sequencing-with-returns","title":"Sequencing with returns","text":"<p>Mix <code>Throws</code> with <code>Returns</code> using <code>Then()</code>:</p> <p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Throws&lt;InvalidOperationException&gt;()\n    .Then().Returns(2);\n\nservice.GetNumber(); // 1\nservice.GetNumber(); // throws InvalidOperationException\nservice.GetNumber(); // 2\n</code></pre>"},{"location":"methods/throwing/#async-methods","title":"Async methods","text":"<p>For Task/Task or ValueTask/ValueTask, <code>Throws</code> raises the exception when the method is invoked, just like synchronous methods. Use async-aware assertions in tests when appropriate. <p>Example</p> <pre><code>imposter.GetNumberAsync().Throws&lt;TimeoutException&gt;();\nawait Assert.ThrowsAsync&lt;TimeoutException&gt;(() =&gt; service.GetNumberAsync());\n</code></pre> <p>See more examples on GitHub.</p> <p>Note</p> <ul> <li>Repeating <code>Throws</code> without <code>Then()</code> is invalid; separate distinct throwing steps with <code>Then()</code>.</li> </ul>"},{"location":"methods/verification/","title":"Verification","text":"<p>Verify that methods were invoked the expected number of times with specific arguments. Use <code>Called(Count.*)</code> on the method builder.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IVerifyService))]\n\npublic interface IVerifyService\n{\n    void Increment(int v);\n    int Combine(int a, int b);\n}\n</code></pre>"},{"location":"methods/verification/#basic-counts","title":"Basic counts","text":"<p>Example</p> <pre><code>service.Increment(1);\nservice.Increment(2);\n\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Increment(2).Called(Count.Once());\n</code></pre>"},{"location":"methods/verification/#matching-arguments","title":"Matching arguments","text":"<p>Verification respects the same argument matching rules used for arrangements:</p> <p>Example</p> <pre><code>// See more examples in repo tests\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 10)).Called(Count.Exactly(3));\nimposter.Combine(Arg&lt;int&gt;.Is(x =&gt; x &gt; 0), Arg&lt;int&gt;.Is(y =&gt; y &lt; 10)).Called(Count.Once());\n</code></pre>"},{"location":"methods/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown. The message includes both the expected/actual counts and, when available, a textual list of performed invocations:</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\nPerformed invocations:\n{invocation1}\n{invocation2}\n...\n</code></pre> <p>Use this list to quickly see which calls were actually made and why the verification did not match your expectations.</p>"},{"location":"properties/","title":"Property Impersonation","text":"<p>Configure getters and setters, verify writes, and forward to base implementations for class targets.</p>"},{"location":"properties/#creating-an-imposter","title":"Creating an imposter","text":"<p>Define the target interface and enable generation:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\nusing Imposter.Tests.Features.PropertyImposter;\n\n[assembly: GenerateImposter(typeof(IPropertySetupSut))]\n\npublic interface IPropertySetupSut\n{\n    int Age { get; set; }\n\n    int Name { get; }\n\n    int LastName { set; }\n}\n</code></pre>"},{"location":"properties/#getter","title":"Getter","text":"<p>Example</p> <pre><code>imposter.Age.Getter().Returns(33);\nvar value = service.Age; // 33\n\n// Sequencing\nimposter.Age.Getter().Returns(10).Then().Returns(20);\nvar first = service.Age;  // 10\nvar second = service.Age; // 20\nvar third = service.Age;  // 20 (sequence exhausted)\n</code></pre>"},{"location":"properties/#setter","title":"Setter","text":"<p>Example</p> <pre><code>// Observe writes\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt; { /* side-effects */ });\n\nvar service = imposter.Instance();\nservice.Age = 10;\nservice.Age = 11; // two writes in total\n\n// Verify writes\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Age.Setter(Arg&lt;int&gt;.Is(11)).Called(Count.Once());\n</code></pre>"},{"location":"properties/#base-implementation","title":"Base Implementation","text":"<p>Forward to the base implementation for overridable class members:</p> <p>Example</p> <pre><code>imposter.Age.Getter().UseBaseImplementation();\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).UseBaseImplementation();\n\nvar service = imposter.Instance();\nvar original = service.Age; // returns base value\nservice.Age = 10;           // uses base setter\n</code></pre>"},{"location":"properties/callbacks/","title":"Property Callbacks","text":"<p>Run side effects when a property is written or read.</p>"},{"location":"properties/callbacks/#setter-callbacks","title":"Setter callbacks","text":"<p>Example</p> <pre><code>imposter.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt;\n{\n    // observe or react to writes\n});\n\nvar service = imposter.Instance();\nservice.Age = 10; // triggers callback\n</code></pre>"},{"location":"properties/callbacks/#getter-callbacks","title":"Getter callbacks","text":"<p>Example</p> <pre><code>imposter.Age.Getter().Callback(() =&gt;\n{\n    // observe reads; combine with Returns/Then\n}).Returns(10);\n\nvar service = imposter.Instance();\nvar value = service.Age; // 10 and callback invoked\n</code></pre> <p>Tips - Use <code>Arg&lt;T&gt;</code> to scope callbacks to specific values. - Combine with <code>Called(Count.\u2026)</code> for verification.</p>"},{"location":"properties/protected-members/","title":"Protected Properties","text":"<p>Virtual and abstract protected properties can be configured on the imposter.</p>"},{"location":"properties/protected-members/#gettersetter-with-wrapper","title":"Getter/Setter with wrapper","text":"<p>Example</p> <pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual int ProtectedAge { get; set; } = 7;\n    public virtual int ReadProtected() =&gt; ProtectedAge;\n    public virtual void WriteProtected(int value) =&gt; ProtectedAge = value;\n}\n\nvar imposter = new MyServiceImposter();\n\n// Arrange getter\nimposter.ProtectedAge.Getter().Returns(33);\nimposter.ProtectedAge.Setter(Arg&lt;int&gt;.Is(10)).Called(Count.Once());\n</code></pre>"},{"location":"properties/sequential-returns/","title":"Property Sequential Returns","text":"<p>Return a sequence of values on successive reads.</p> <p>Example</p> <pre><code>imposter.Age.Getter()\n    .Returns(10)\n    .Then().Returns(20)\n    .Then().Returns(30);\n\nvar a = service.Age; // 10\nvar b = service.Age; // 20\nvar c = service.Age; // 30\nvar d = service.Age; // 30 - last setup repeats\n</code></pre> <p>Combine sequencing with callbacks if you need to record read order or side effects:</p> <p>Example</p> <pre><code>var firstSeen = 0;\nvar secondSeen = 0;\n\nimposter.Age.Getter()\n    .Returns(10)\n    .Then().Returns(20)\n    .Then().Returns(30)\n    .Callback(() =&gt; firstSeen++)\n    .Then()\n    .Callback(() =&gt; secondSeen++);\n\nvar a = service.Age; // 10, firstSeen == 1, secondSeen == 0\nvar b = service.Age; // 20, firstSeen == 1, secondSeen == 1\nvar c = service.Age; // 30, firstSeen == 2, secondSeen == 1\n</code></pre>"},{"location":"properties/throwing/","title":"Property Throwing","text":"<p>In Explicit mode or when desired, configure getters to throw. For setters, prefer verification via <code>Called(Count...)</code> and callbacks.</p>"},{"location":"properties/throwing/#getter-throwing","title":"Getter throwing","text":"<p>Example</p> <pre><code>imposter.Age.Getter().Throws&lt;InvalidOperationException&gt;();\n\nvar service = imposter.Instance();\n\n// Read throws the configured exception\nShould.Throw&lt;InvalidOperationException&gt;(() =&gt; service.Age);\n</code></pre>"},{"location":"properties/throwing/#setter-validation-with-throwing-callbacks","title":"Setter validation with throwing callbacks","text":"<p>Example</p> <pre><code>imposter.Age.Setter(Arg&lt;int&gt;.Any())\n    .Callback(_ =&gt; throw new InvalidOperationException(\"Callback error\"));\n\nvar service = imposter.Instance();\n\n// Setter callback throws, but the attempted value is still tracked\nShould.Throw&lt;InvalidOperationException&gt;(() =&gt; service.Age = 42);\n\nimposter.Age.Setter(Arg&lt;int&gt;.Is(v =&gt; v == 42)).Called(Count.Exactly(1));\n</code></pre>"},{"location":"properties/verification/","title":"Property Verification","text":""},{"location":"properties/verification/#setter-verification","title":"Setter verification","text":"<p>Example</p> <pre><code>service.Age = 33;\nservice.Age = 34;\n\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Age.Setter(Arg&lt;int&gt;.Is(34)).Called(Count.Once());\n</code></pre>"},{"location":"properties/verification/#getter-verification","title":"Getter verification","text":"<p>Example</p> <pre><code>var _ = service.Age;\nimposter.Age.Getter().Called(Count.Once());\n</code></pre>"},{"location":"properties/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown with the message:</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\n</code></pre> <p>Examples:</p> <p>Example</p> <pre><code>// Setter expected once for value 34, but no matching write occurred\nimposter.Age.Setter(Arg&lt;int&gt;.Is(34)).Called(Count.Once());\n// throws: \"Invocation was expected to be performed exactly 1 time(s) but instead was performed 0 times.\"\n\n// Getter expected at least 2 reads, but only 1\nvar _ = service.Age;\nimposter.Age.Getter().Called(Count.AtLeast(2));\n// throws: \"Invocation was expected to be performed at least 2 time(s) but instead was performed 1 times.\"\n</code></pre> <p>Tips - Use <code>Arg&lt;T&gt;</code> matchers to target specific values. - Pair verifications with callbacks when you need to capture payloads.</p>"}]}