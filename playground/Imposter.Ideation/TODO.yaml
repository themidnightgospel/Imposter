Constraints:
  - Minimize reflection
  - Target C# 7.0

FEATURES:
  HIGH:
    Done:
      - Generic method support
      - Async method support
      - Generic interface support - for closed generics
      - Property
        - Returns single and multiple values
        - Setter callback's
        - Setup property to act as a normal property (when set, same value is read). Support for initial value
        - Setup all properties (move to an interface as explicit implementation)
        - Verify set
      - Put method related types in a sub-class of Imposter class, that way we won't have to repeat generics every time and less things to worry about for naming collisions. - DONE
      - Indexer setup support
      - Event setup support
      - For c# 14, declare Impsoter as an extension to imposter target type
      - Add support for Strict and Loose modes (called explicit and implicit)
      - Impostering class (abstract class, virtual methods) - see NonInterfaceTargets/ for the latest PoC
      - segegate imposter group interface to guide user users to use correct builder methods, for properties, indexers and events also.
      - protected method mocking.
      - cleanup SyntaxFactoryHelper
      - TODO Use cancellation token during code generation
      - add test that checks that multiple [GenerateImposter] attribute for the same type still works and does not generate 2 imposters but 1.
      - In ImposterTargetInstance, custom members like _imposter might collide with interface member names - DONE
      - Add docstrings to types defined in Abstractions
      - Make imposter thread safe
      - Rename HasMatchingSetup methods to HasMatchingInvocationImposterGroup
      - make imposter sealed
      - Use fully qualified name wherever possible
      - Make sure metadata structs are passed as readonly
      - Analyze if [MethodImpl(MethodImplOptions.AggressiveInlining)] is productive or counter-productive
      - Make sure all the metadata structs are passed as readonly using in modifier
      - Add <auto-generated /> comment at the beginning
      - NOTE / To avoid naming collision, rename parameters in Invoke/Set methods instead of internal fields/methods
      - UseBaseImplementation at the property/indexer level (not only Getter/Setter level).
      - add test that with Property  with default behaviour uses initial value assigned to that property (for class imposters).
    IN Progress:
      - Add Docs page
      - Test nuget package for different versions of the Roslyn
      - make sure imposter builds properly for all the major Microsoft.CodeAnalysis.CSharp versions, ideally using automated tests. (Use conditinals for the target framework and language version, and CSharp package and run tests for all the combination)
    NOT Started:
      - fix TODOs in code
      - Setup github action to build, test and publish nuget packages
      - Publish as a nuget package from github actions
      - Review entire codebase and refactor
      - "VerifyNoOtherCalls" verifier
      - Add a sample project.
      - UseBaseImplementation for interface members

  MEDIUM:
    - NOT Started:
        - Go thru all the SyntaxFactory builder classes, like ClassDeclaration and replace with custom builders.
        - Add support for open generic imposters. Example, `[GenerateImposter(typeof(IGenericSut<,>))]`
        - Proper diagnostics

  LOW:
    - NOT Started:
        - Support for 'scoped' parameters
        - Add unit tests for InterfaceSymbolExtensions
        - Chaining event raise to method, property and indexer. Can be achieved with Method.Callback + Event.Raise, so probably not important.
        - Write a blog posts about the project

OPTIMIZATIONS:
  - Need to make sure that every name in imposter class has unique name and does not collide with user provided names 
  - Create syntax builder classes to avoid .With builder methods that has terribe performance (add tests for this too)
  - Identify syntaxes that can be cached
  - Add benchamrks for the code generator itself.
  - Add benchamrks for syntax builder classes, showcase that it performs better than built-in .With methods.
  - Take a look at file name convention, specially of "Builders" and make sure they are consistent across
  - Make sure Metadata is always stack allocated and not copied

MISSING FEATURES:
  - VerifyNoOtherCalls
  - Ordered verification, Substitute.InOrder. It can be achieved currently by setting up callbacks and storing some flags in a list.
  - 
