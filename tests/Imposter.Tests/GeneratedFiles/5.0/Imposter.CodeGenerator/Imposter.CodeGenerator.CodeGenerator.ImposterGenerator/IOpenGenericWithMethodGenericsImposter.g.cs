// <auto-generated />
#nullable enable
#pragma warning disable
using global::System;
using global::System.Linq;
using global::System.Collections.Generic;
using global::System.Threading.Tasks;
using global::System.Diagnostics;
using global::System.Runtime.CompilerServices;
using global::Imposter.Abstractions;
using global::System.Collections.Concurrent;
using global::Imposter.Tests.Features.OpenGenericImposter;

namespace Imposter.Tests.Features.OpenGenericImposter
{
    [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
    public sealed class IOpenGenericWithMethodGenericsImposter<T> : global::Imposter.Abstractions.IHaveImposterInstance<global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenerics<T>>
    {
        private readonly DoSomethingMethodImposterCollection _doSomethingMethodImposterCollection;
        private readonly TransformMethodImposterCollection _transformMethodImposterCollection;
        private readonly MapMethodImposterCollection _mapMethodImposterCollection;
        private readonly DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection = new DoSomethingMethodInvocationHistoryCollection();
        private readonly TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection = new TransformMethodInvocationHistoryCollection();
        private readonly MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection = new MapMethodInvocationHistoryCollection();
        public IDoSomethingMethodImposterBuilder<TArg> DoSomething<TArg>(global::Imposter.Abstractions.Arg<TArg> arg)
        {
            return new DoSomethingMethodImposter<TArg>.Builder(_doSomethingMethodImposterCollection, _doSomethingMethodInvocationHistoryCollection, new DoSomethingArgumentsCriteria<TArg>(arg));
        }

        public ITransformMethodImposterBuilder<TArg> Transform<TArg>(global::Imposter.Abstractions.Arg<T> input)
        {
            return new TransformMethodImposter<TArg>.Builder(_transformMethodImposterCollection, _transformMethodInvocationHistoryCollection, new TransformArgumentsCriteria<TArg>(input));
        }

        public IMapMethodImposterBuilder<TSource, TResult> Map<TSource, TResult>(global::Imposter.Abstractions.Arg<TSource> source)
        {
            return new MapMethodImposter<TSource, TResult>.Builder(_mapMethodImposterCollection, _mapMethodInvocationHistoryCollection, new MapArgumentsCriteria<TSource, TResult>(source));
        }

        private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
        private ImposterTargetInstance _imposterInstance;
        global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenerics<T> global::Imposter.Abstractions.IHaveImposterInstance<global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenerics<T>>.Instance()
        {
            return _imposterInstance;
        }

        // void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)
        public delegate void DoSomethingDelegate<TArg>(TArg arg);
        // void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)
        public delegate void DoSomethingCallbackDelegate<TArg>(TArg arg);
        // void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)
        public delegate global::System.Exception DoSomethingExceptionGeneratorDelegate<TArg>(TArg arg);
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class DoSomethingArguments<TArg>
        {
            public TArg arg;
            internal DoSomethingArguments(TArg arg)
            {
                this.arg = arg;
            }

            public DoSomethingArguments<TArgTarget> As<TArgTarget>()
            {
                return new DoSomethingArguments<TArgTarget>(TypeCaster.Cast<TArg, TArgTarget>(arg));
            }
        }

        // void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class DoSomethingArgumentsCriteria<TArg>
        {
            public global::Imposter.Abstractions.Arg<TArg> arg { get; }

            public DoSomethingArgumentsCriteria(global::Imposter.Abstractions.Arg<TArg> arg)
            {
                this.arg = arg;
            }

            public bool Matches(DoSomethingArguments<TArg> arguments)
            {
                return arg.Matches(arguments.arg);
            }

            public DoSomethingArgumentsCriteria<TArgTarget> As<TArgTarget>()
            {
                return new DoSomethingArgumentsCriteria<TArgTarget>(global::Imposter.Abstractions.Arg<TArgTarget>.Is(it => global::Imposter.Abstractions.TypeCaster.TryCast<TArgTarget, TArg>(it, out TArg argTarget) && arg.Matches(argTarget)));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IDoSomethingMethodInvocationHistory
        {
            bool Matches<TArgTarget>(DoSomethingArgumentsCriteria<TArgTarget> criteria);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class DoSomethingMethodInvocationHistory<TArg> : IDoSomethingMethodInvocationHistory
        {
            internal DoSomethingArguments<TArg> Arguments;
            internal global::System.Exception? Exception;
            public DoSomethingMethodInvocationHistory(DoSomethingArguments<TArg> Arguments, global::System.Exception? Exception)
            {
                this.Arguments = Arguments;
                this.Exception = Exception;
            }

            public bool Matches<TArgTarget>(DoSomethingArgumentsCriteria<TArgTarget> criteria)
            {
                return (typeof(TArgTarget) == typeof(TArg)) && criteria.As<TArg>().Matches(Arguments);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class DoSomethingMethodInvocationHistoryCollection
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<IDoSomethingMethodInvocationHistory> _invocationHistory = new global::System.Collections.Concurrent.ConcurrentStack<IDoSomethingMethodInvocationHistory>();
            internal void Add(IDoSomethingMethodInvocationHistory invocationHistory)
            {
                _invocationHistory.Push(invocationHistory);
            }

            internal int Count<TArg>(DoSomethingArgumentsCriteria<TArg> argumentsCriteria)
            {
                return _invocationHistory.Count(it => it.Matches<TArg>(argumentsCriteria));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class DoSomethingMethodImposterCollection
        {
            private readonly DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public DoSomethingMethodImposterCollection(DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._doSomethingMethodInvocationHistoryCollection = _doSomethingMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            private readonly global::System.Collections.Concurrent.ConcurrentStack<IDoSomethingMethodImposter> _imposters = new global::System.Collections.Concurrent.ConcurrentStack<IDoSomethingMethodImposter>();
            internal DoSomethingMethodImposter<TArg> AddNew<TArg>()
            {
                var imposter = new DoSomethingMethodImposter<TArg>(_doSomethingMethodInvocationHistoryCollection, _invocationBehavior);
                _imposters.Push(imposter);
                return imposter;
            }

            internal IDoSomethingMethodImposter<TArg> GetImposterWithMatchingInvocationImposterGroup<TArg>(DoSomethingArguments<TArg> arguments)
            {
                return _imposters.Select(it => it.As<TArg>()).Where(it => it != null).Select(it => it!).FirstOrDefault(it => it.HasMatchingInvocationImposterGroup(arguments)) ?? AddNew<TArg>();
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        class DoSomethingMethodInvocationImposterGroup<TArg>
        {
            internal static DoSomethingMethodInvocationImposterGroup<TArg> Default = new DoSomethingMethodInvocationImposterGroup<TArg>(new DoSomethingArgumentsCriteria<TArg>(global::Imposter.Abstractions.Arg<TArg>.Any()));
            internal DoSomethingArgumentsCriteria<TArg> ArgumentsCriteria { get; }

            private readonly global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter>();
            private MethodInvocationImposter? _lastestInvocationImposter;
            public DoSomethingMethodInvocationImposterGroup(DoSomethingArgumentsCriteria<TArg> argumentsCriteria)
            {
                ArgumentsCriteria = argumentsCriteria;
            }

            internal MethodInvocationImposter AddInvocationImposter()
            {
                MethodInvocationImposter invocationImposter = new MethodInvocationImposter();
                _invocationImposters.Enqueue(invocationImposter);
                return invocationImposter;
            }

            private MethodInvocationImposter? GetInvocationImposter()
            {
                if (_invocationImposters.TryDequeue(out var invocationImposter))
                {
                    if (!invocationImposter.IsEmpty)
                    {
                        _lastestInvocationImposter = invocationImposter;
                    }

                    return invocationImposter;
                }

                return _lastestInvocationImposter;
            }

            public void Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, TArg arg)
            {
                var invocationImposter = GetInvocationImposter();
                if (invocationImposter == null)
                {
                    if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                    }

                    invocationImposter = MethodInvocationImposter.Default;
                }

                invocationImposter.Invoke(invocationBehavior, methodDisplayName, arg);
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class MethodInvocationImposter
            {
                internal static MethodInvocationImposter Default;
                static MethodInvocationImposter()
                {
                    Default = new MethodInvocationImposter();
                    Default._resultGenerator = DefaultResultGenerator;
                }

                private DoSomethingDelegate<TArg>? _resultGenerator;
                private readonly global::System.Collections.Concurrent.ConcurrentQueue<DoSomethingCallbackDelegate<TArg>> _callbacks = new global::System.Collections.Concurrent.ConcurrentQueue<DoSomethingCallbackDelegate<TArg>>();
                internal bool IsEmpty => (_resultGenerator == null) && (_callbacks.Count == 0);

                public void Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, TArg arg)
                {
                    if (_resultGenerator == null)
                    {
                        if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                        {
                            throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                        }

                        _resultGenerator = DefaultResultGenerator;
                    }

                    _resultGenerator.Invoke(arg);
                    foreach (var callback in _callbacks)
                    {
                        callback(arg);
                    }
                }

                internal void Callback(DoSomethingCallbackDelegate<TArg> callback)
                {
                    _callbacks.Enqueue(callback);
                }

                internal void Throws(DoSomethingExceptionGeneratorDelegate<TArg> exceptionGenerator)
                {
                    _resultGenerator = (TArg arg) =>
                    {
                        throw exceptionGenerator(arg);
                    };
                }

                internal static void DefaultResultGenerator(TArg arg)
                {
                }
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IDoSomethingMethodInvocationImposterGroupCallback<TArg>
        {
            IDoSomethingMethodInvocationImposterGroupContinuation<TArg> Callback(DoSomethingCallbackDelegate<TArg> callback);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IDoSomethingMethodInvocationImposterGroupContinuation<TArg> : IDoSomethingMethodInvocationImposterGroupCallback<TArg>
        {
            IDoSomethingMethodInvocationImposterGroup<TArg> Then();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IDoSomethingMethodInvocationImposterGroup<TArg> : IDoSomethingMethodInvocationImposterGroupCallback<TArg>
        {
            IDoSomethingMethodInvocationImposterGroupContinuation<TArg> Throws<TException>()
                where TException : global::System.Exception, new();
            IDoSomethingMethodInvocationImposterGroupContinuation<TArg> Throws(global::System.Exception exception);
            IDoSomethingMethodInvocationImposterGroupContinuation<TArg> Throws(DoSomethingExceptionGeneratorDelegate<TArg> exceptionGenerator);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface IDoSomethingMethodImposter
        {
            IDoSomethingMethodImposter<TArgTarget>? As<TArgTarget>();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface IDoSomethingMethodImposter<TArg> : IDoSomethingMethodImposter
        {
            void Invoke(TArg arg);
            bool HasMatchingInvocationImposterGroup(DoSomethingArguments<TArg> arguments);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface DoSomethingInvocationVerifier<TArg>
        {
            void Called(Count count);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IDoSomethingMethodImposterBuilder<TArg> : IDoSomethingMethodInvocationImposterGroup<TArg>, IDoSomethingMethodInvocationImposterGroupCallback<TArg>, DoSomethingInvocationVerifier<TArg>
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class DoSomethingMethodImposter<TArg> : IDoSomethingMethodImposter<TArg>
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<DoSomethingMethodInvocationImposterGroup<TArg>> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentStack<DoSomethingMethodInvocationImposterGroup<TArg>>();
            private readonly DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public DoSomethingMethodImposter(DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._doSomethingMethodInvocationHistoryCollection = _doSomethingMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            IDoSomethingMethodImposter<TArgTarget>? IDoSomethingMethodImposter.As<TArgTarget>()
            {
                if (typeof(TArgTarget).IsAssignableTo(typeof(TArg)))
                {
                    return new Adapter<TArgTarget>(this);
                }

                return null;
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            private class Adapter<TArgTarget> : IDoSomethingMethodImposter<TArgTarget>
            {
                private readonly DoSomethingMethodImposter<TArg> _target;
                public Adapter(DoSomethingMethodImposter<TArg> target)
                {
                    _target = target;
                }

                public void Invoke(TArgTarget arg)
                {
                    _target.Invoke(global::Imposter.Abstractions.TypeCaster.Cast<TArgTarget, TArg>(arg));
                }

                public bool HasMatchingInvocationImposterGroup(DoSomethingArguments<TArgTarget> arguments)
                {
                    return _target.HasMatchingInvocationImposterGroup(arguments.As<TArg>());
                }

                IDoSomethingMethodImposter<TArgTarget1>? IDoSomethingMethodImposter.As<TArgTarget1>()
                {
                    throw new NotImplementedException();
                }
            }

            public bool HasMatchingInvocationImposterGroup(DoSomethingArguments<TArg> arguments)
            {
                return FindMatchingInvocationImposterGroup(arguments) != null;
            }

            private DoSomethingMethodInvocationImposterGroup<TArg>? FindMatchingInvocationImposterGroup(DoSomethingArguments<TArg> arguments)
            {
                foreach (var invocationImposterGroup in _invocationImposters)
                {
                    if (invocationImposterGroup.ArgumentsCriteria.Matches(arguments))
                        return invocationImposterGroup;
                }

                return null;
            }

            public void Invoke(TArg arg)
            {
                var arguments = new DoSomethingArguments<TArg>(arg);
                var matchingInvocationImposterGroup = FindMatchingInvocationImposterGroup(arguments);
                if (matchingInvocationImposterGroup == default)
                {
                    if (_invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException("void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)");
                    }

                    matchingInvocationImposterGroup = DoSomethingMethodInvocationImposterGroup<TArg>.Default;
                }

                try
                {
                    matchingInvocationImposterGroup.Invoke(_invocationBehavior, "void IOpenGenericWithMethodGenerics<T>.DoSomething<TArg>(TArg arg)", arg);
                    _doSomethingMethodInvocationHistoryCollection.Add(new DoSomethingMethodInvocationHistory<TArg>(arguments, default));
                }
                catch (global::System.Exception ex)
                {
                    _doSomethingMethodInvocationHistoryCollection.Add(new DoSomethingMethodInvocationHistory<TArg>(arguments, ex));
                    throw;
                }
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class Builder : IDoSomethingMethodImposterBuilder<TArg>, IDoSomethingMethodInvocationImposterGroupContinuation<TArg>
            {
                private readonly DoSomethingMethodImposterCollection _imposterCollection;
                private readonly DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection;
                private readonly DoSomethingArgumentsCriteria<TArg> _argumentsCriteria;
                private readonly DoSomethingMethodInvocationImposterGroup<TArg> _invocationImposterGroup;
                private DoSomethingMethodInvocationImposterGroup<TArg>.MethodInvocationImposter _currentInvocationImposter;
                public Builder(DoSomethingMethodImposterCollection _imposterCollection, DoSomethingMethodInvocationHistoryCollection _doSomethingMethodInvocationHistoryCollection, DoSomethingArgumentsCriteria<TArg> _argumentsCriteria)
                {
                    this._imposterCollection = _imposterCollection;
                    this._doSomethingMethodInvocationHistoryCollection = _doSomethingMethodInvocationHistoryCollection;
                    this._argumentsCriteria = _argumentsCriteria;
                    this._invocationImposterGroup = new DoSomethingMethodInvocationImposterGroup<TArg>(_argumentsCriteria);
                    DoSomethingMethodImposter<TArg> methodImposter = _imposterCollection.AddNew<TArg>();
                    methodImposter._invocationImposters.Push(_invocationImposterGroup);
                    this._currentInvocationImposter = this._invocationImposterGroup.AddInvocationImposter();
                }

                IDoSomethingMethodInvocationImposterGroupContinuation<TArg> IDoSomethingMethodInvocationImposterGroup<TArg>.Throws<TException>()
                {
                    _currentInvocationImposter.Throws((TArg arg) =>
                    {
                        throw new TException();
                    });
                    return this;
                }

                IDoSomethingMethodInvocationImposterGroupContinuation<TArg> IDoSomethingMethodInvocationImposterGroup<TArg>.Throws(global::System.Exception exception)
                {
                    _currentInvocationImposter.Throws((TArg arg) =>
                    {
                        throw exception;
                    });
                    return this;
                }

                IDoSomethingMethodInvocationImposterGroupContinuation<TArg> IDoSomethingMethodInvocationImposterGroup<TArg>.Throws(DoSomethingExceptionGeneratorDelegate<TArg> exceptionGenerator)
                {
                    _currentInvocationImposter.Throws((TArg arg) =>
                    {
                        throw exceptionGenerator.Invoke(arg);
                    });
                    return this;
                }

                IDoSomethingMethodInvocationImposterGroupContinuation<TArg> IDoSomethingMethodInvocationImposterGroupCallback<TArg>.Callback(DoSomethingCallbackDelegate<TArg> callback)
                {
                    _currentInvocationImposter.Callback(callback);
                    return this;
                }

                IDoSomethingMethodInvocationImposterGroup<TArg> IDoSomethingMethodInvocationImposterGroupContinuation<TArg>.Then()
                {
                    this._currentInvocationImposter = _invocationImposterGroup.AddInvocationImposter();
                    return this;
                }

                void DoSomethingInvocationVerifier<TArg>.Called(global::Imposter.Abstractions.Count count)
                {
                    var invocationCount = _doSomethingMethodInvocationHistoryCollection.Count<TArg>(_argumentsCriteria);
                    if (!count.Matches(invocationCount))
                    {
                        throw new global::Imposter.Abstractions.VerificationFailedException(count, invocationCount);
                    }
                }
            }
        }

        // TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)
        public delegate TResult MapDelegate<TSource, TResult>(TSource source);
        // TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)
        public delegate void MapCallbackDelegate<TSource, TResult>(TSource source);
        // TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)
        public delegate global::System.Exception MapExceptionGeneratorDelegate<TSource, TResult>(TSource source);
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class MapArguments<TSource, TResult>
        {
            public TSource source;
            internal MapArguments(TSource source)
            {
                this.source = source;
            }

            public MapArguments<TSourceTarget, TResultTarget> As<TSourceTarget, TResultTarget>()
            {
                return new MapArguments<TSourceTarget, TResultTarget>(TypeCaster.Cast<TSource, TSourceTarget>(source));
            }
        }

        // TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class MapArgumentsCriteria<TSource, TResult>
        {
            public global::Imposter.Abstractions.Arg<TSource> source { get; }

            public MapArgumentsCriteria(global::Imposter.Abstractions.Arg<TSource> source)
            {
                this.source = source;
            }

            public bool Matches(MapArguments<TSource, TResult> arguments)
            {
                return source.Matches(arguments.source);
            }

            public MapArgumentsCriteria<TSourceTarget, TResultTarget> As<TSourceTarget, TResultTarget>()
            {
                return new MapArgumentsCriteria<TSourceTarget, TResultTarget>(global::Imposter.Abstractions.Arg<TSourceTarget>.Is(it => global::Imposter.Abstractions.TypeCaster.TryCast<TSourceTarget, TSource>(it, out TSource sourceTarget) && source.Matches(sourceTarget)));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IMapMethodInvocationHistory
        {
            bool Matches<TSourceTarget, TResultTarget>(MapArgumentsCriteria<TSourceTarget, TResultTarget> criteria);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class MapMethodInvocationHistory<TSource, TResult> : IMapMethodInvocationHistory
        {
            internal MapArguments<TSource, TResult> Arguments;
            internal TResult? Result;
            internal global::System.Exception? Exception;
            public MapMethodInvocationHistory(MapArguments<TSource, TResult> Arguments, TResult? Result, global::System.Exception? Exception)
            {
                this.Arguments = Arguments;
                this.Result = Result;
                this.Exception = Exception;
            }

            public bool Matches<TSourceTarget, TResultTarget>(MapArgumentsCriteria<TSourceTarget, TResultTarget> criteria)
            {
                return ((typeof(TSourceTarget) == typeof(TSource)) && (typeof(TResult) == typeof(TResultTarget))) && criteria.As<TSource, TResult>().Matches(Arguments);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class MapMethodInvocationHistoryCollection
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<IMapMethodInvocationHistory> _invocationHistory = new global::System.Collections.Concurrent.ConcurrentStack<IMapMethodInvocationHistory>();
            internal void Add(IMapMethodInvocationHistory invocationHistory)
            {
                _invocationHistory.Push(invocationHistory);
            }

            internal int Count<TSource, TResult>(MapArgumentsCriteria<TSource, TResult> argumentsCriteria)
            {
                return _invocationHistory.Count(it => it.Matches<TSource, TResult>(argumentsCriteria));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class MapMethodImposterCollection
        {
            private readonly MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public MapMethodImposterCollection(MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._mapMethodInvocationHistoryCollection = _mapMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            private readonly global::System.Collections.Concurrent.ConcurrentStack<IMapMethodImposter> _imposters = new global::System.Collections.Concurrent.ConcurrentStack<IMapMethodImposter>();
            internal MapMethodImposter<TSource, TResult> AddNew<TSource, TResult>()
            {
                var imposter = new MapMethodImposter<TSource, TResult>(_mapMethodInvocationHistoryCollection, _invocationBehavior);
                _imposters.Push(imposter);
                return imposter;
            }

            internal IMapMethodImposter<TSource, TResult> GetImposterWithMatchingInvocationImposterGroup<TSource, TResult>(MapArguments<TSource, TResult> arguments)
            {
                return _imposters.Select(it => it.As<TSource, TResult>()).Where(it => it != null).Select(it => it!).FirstOrDefault(it => it.HasMatchingInvocationImposterGroup(arguments)) ?? AddNew<TSource, TResult>();
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        class MapMethodInvocationImposterGroup<TSource, TResult>
        {
            internal static MapMethodInvocationImposterGroup<TSource, TResult> Default = new MapMethodInvocationImposterGroup<TSource, TResult>(new MapArgumentsCriteria<TSource, TResult>(global::Imposter.Abstractions.Arg<TSource>.Any()));
            internal MapArgumentsCriteria<TSource, TResult> ArgumentsCriteria { get; }

            private readonly global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter>();
            private MethodInvocationImposter? _lastestInvocationImposter;
            public MapMethodInvocationImposterGroup(MapArgumentsCriteria<TSource, TResult> argumentsCriteria)
            {
                ArgumentsCriteria = argumentsCriteria;
            }

            internal MethodInvocationImposter AddInvocationImposter()
            {
                MethodInvocationImposter invocationImposter = new MethodInvocationImposter();
                _invocationImposters.Enqueue(invocationImposter);
                return invocationImposter;
            }

            private MethodInvocationImposter? GetInvocationImposter()
            {
                if (_invocationImposters.TryDequeue(out var invocationImposter))
                {
                    if (!invocationImposter.IsEmpty)
                    {
                        _lastestInvocationImposter = invocationImposter;
                    }

                    return invocationImposter;
                }

                return _lastestInvocationImposter;
            }

            public TResult Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, TSource source)
            {
                var invocationImposter = GetInvocationImposter();
                if (invocationImposter == null)
                {
                    if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                    }

                    invocationImposter = MethodInvocationImposter.Default;
                }

                return invocationImposter.Invoke(invocationBehavior, methodDisplayName, source);
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class MethodInvocationImposter
            {
                internal static MethodInvocationImposter Default;
                static MethodInvocationImposter()
                {
                    Default = new MethodInvocationImposter();
                    Default.Returns(DefaultResultGenerator);
                }

                private MapDelegate<TSource, TResult>? _resultGenerator;
                private readonly global::System.Collections.Concurrent.ConcurrentQueue<MapCallbackDelegate<TSource, TResult>> _callbacks = new global::System.Collections.Concurrent.ConcurrentQueue<MapCallbackDelegate<TSource, TResult>>();
                internal bool IsEmpty => (_resultGenerator == null) && (_callbacks.Count == 0);

                public TResult Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, TSource source)
                {
                    if (_resultGenerator == null)
                    {
                        if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                        {
                            throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                        }

                        _resultGenerator = DefaultResultGenerator;
                    }

                    TResult result = _resultGenerator.Invoke(source);
                    foreach (var callback in _callbacks)
                    {
                        callback(source);
                    }

                    return result;
                }

                internal void Callback(MapCallbackDelegate<TSource, TResult> callback)
                {
                    _callbacks.Enqueue(callback);
                }

                internal void Returns(MapDelegate<TSource, TResult> resultGenerator)
                {
                    _resultGenerator = resultGenerator;
                }

                internal void Returns(TResult value)
                {
                    _resultGenerator = (TSource source) =>
                    {
                        return value;
                    };
                }

                internal void Throws(MapExceptionGeneratorDelegate<TSource, TResult> exceptionGenerator)
                {
                    _resultGenerator = (TSource source) =>
                    {
                        throw exceptionGenerator(source);
                    };
                }

                internal static TResult DefaultResultGenerator(TSource source)
                {
                    return default !;
                }
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IMapMethodInvocationImposterGroupCallback<TSource, TResult>
        {
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Callback(MapCallbackDelegate<TSource, TResult> callback);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IMapMethodInvocationImposterGroupContinuation<TSource, TResult> : IMapMethodInvocationImposterGroupCallback<TSource, TResult>
        {
            IMapMethodInvocationImposterGroup<TSource, TResult> Then();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IMapMethodInvocationImposterGroup<TSource, TResult> : IMapMethodInvocationImposterGroupCallback<TSource, TResult>
        {
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Throws<TException>()
                where TException : global::System.Exception, new();
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Throws(global::System.Exception exception);
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Throws(MapExceptionGeneratorDelegate<TSource, TResult> exceptionGenerator);
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Returns(MapDelegate<TSource, TResult> resultGenerator);
            IMapMethodInvocationImposterGroupContinuation<TSource, TResult> Returns(TResult value);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface IMapMethodImposter
        {
            IMapMethodImposter<TSourceTarget, TResultTarget>? As<TSourceTarget, TResultTarget>();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface IMapMethodImposter<TSource, TResult> : IMapMethodImposter
        {
            TResult Invoke(TSource source);
            bool HasMatchingInvocationImposterGroup(MapArguments<TSource, TResult> arguments);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface MapInvocationVerifier<TSource, TResult>
        {
            void Called(Count count);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface IMapMethodImposterBuilder<TSource, TResult> : IMapMethodInvocationImposterGroup<TSource, TResult>, IMapMethodInvocationImposterGroupCallback<TSource, TResult>, MapInvocationVerifier<TSource, TResult>
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class MapMethodImposter<TSource, TResult> : IMapMethodImposter<TSource, TResult>
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<MapMethodInvocationImposterGroup<TSource, TResult>> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentStack<MapMethodInvocationImposterGroup<TSource, TResult>>();
            private readonly MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public MapMethodImposter(MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._mapMethodInvocationHistoryCollection = _mapMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            IMapMethodImposter<TSourceTarget, TResultTarget>? IMapMethodImposter.As<TSourceTarget, TResultTarget>()
            {
                if (typeof(TSourceTarget).IsAssignableTo(typeof(TSource)) && typeof(TResult).IsAssignableTo(typeof(TResultTarget)))
                {
                    return new Adapter<TSourceTarget, TResultTarget>(this);
                }

                return null;
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            private class Adapter<TSourceTarget, TResultTarget> : IMapMethodImposter<TSourceTarget, TResultTarget>
            {
                private readonly MapMethodImposter<TSource, TResult> _target;
                public Adapter(MapMethodImposter<TSource, TResult> target)
                {
                    _target = target;
                }

                public TResultTarget Invoke(TSourceTarget source)
                {
                    var result = _target.Invoke(global::Imposter.Abstractions.TypeCaster.Cast<TSourceTarget, TSource>(source));
                    return global::Imposter.Abstractions.TypeCaster.Cast<TResult, TResultTarget>(result);
                }

                public bool HasMatchingInvocationImposterGroup(MapArguments<TSourceTarget, TResultTarget> arguments)
                {
                    return _target.HasMatchingInvocationImposterGroup(arguments.As<TSource, TResult>());
                }

                IMapMethodImposter<TSourceTarget1, TResultTarget1>? IMapMethodImposter.As<TSourceTarget1, TResultTarget1>()
                {
                    throw new NotImplementedException();
                }
            }

            public bool HasMatchingInvocationImposterGroup(MapArguments<TSource, TResult> arguments)
            {
                return FindMatchingInvocationImposterGroup(arguments) != null;
            }

            private MapMethodInvocationImposterGroup<TSource, TResult>? FindMatchingInvocationImposterGroup(MapArguments<TSource, TResult> arguments)
            {
                foreach (var invocationImposterGroup in _invocationImposters)
                {
                    if (invocationImposterGroup.ArgumentsCriteria.Matches(arguments))
                        return invocationImposterGroup;
                }

                return null;
            }

            public TResult Invoke(TSource source)
            {
                var arguments = new MapArguments<TSource, TResult>(source);
                var matchingInvocationImposterGroup = FindMatchingInvocationImposterGroup(arguments);
                if (matchingInvocationImposterGroup == default)
                {
                    if (_invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException("TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)");
                    }

                    matchingInvocationImposterGroup = MapMethodInvocationImposterGroup<TSource, TResult>.Default;
                }

                try
                {
                    var result = matchingInvocationImposterGroup.Invoke(_invocationBehavior, "TResult IOpenGenericWithMethodGenerics<T>.Map<TSource, TResult>(TSource source)", source);
                    _mapMethodInvocationHistoryCollection.Add(new MapMethodInvocationHistory<TSource, TResult>(arguments, result, default));
                    return result;
                }
                catch (global::System.Exception ex)
                {
                    _mapMethodInvocationHistoryCollection.Add(new MapMethodInvocationHistory<TSource, TResult>(arguments, default, ex));
                    throw;
                }
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class Builder : IMapMethodImposterBuilder<TSource, TResult>, IMapMethodInvocationImposterGroupContinuation<TSource, TResult>
            {
                private readonly MapMethodImposterCollection _imposterCollection;
                private readonly MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection;
                private readonly MapArgumentsCriteria<TSource, TResult> _argumentsCriteria;
                private readonly MapMethodInvocationImposterGroup<TSource, TResult> _invocationImposterGroup;
                private MapMethodInvocationImposterGroup<TSource, TResult>.MethodInvocationImposter _currentInvocationImposter;
                public Builder(MapMethodImposterCollection _imposterCollection, MapMethodInvocationHistoryCollection _mapMethodInvocationHistoryCollection, MapArgumentsCriteria<TSource, TResult> _argumentsCriteria)
                {
                    this._imposterCollection = _imposterCollection;
                    this._mapMethodInvocationHistoryCollection = _mapMethodInvocationHistoryCollection;
                    this._argumentsCriteria = _argumentsCriteria;
                    this._invocationImposterGroup = new MapMethodInvocationImposterGroup<TSource, TResult>(_argumentsCriteria);
                    MapMethodImposter<TSource, TResult> methodImposter = _imposterCollection.AddNew<TSource, TResult>();
                    methodImposter._invocationImposters.Push(_invocationImposterGroup);
                    this._currentInvocationImposter = this._invocationImposterGroup.AddInvocationImposter();
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroup<TSource, TResult>.Throws<TException>()
                {
                    _currentInvocationImposter.Throws((TSource source) =>
                    {
                        throw new TException();
                    });
                    return this;
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroup<TSource, TResult>.Throws(global::System.Exception exception)
                {
                    _currentInvocationImposter.Throws((TSource source) =>
                    {
                        throw exception;
                    });
                    return this;
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroup<TSource, TResult>.Throws(MapExceptionGeneratorDelegate<TSource, TResult> exceptionGenerator)
                {
                    _currentInvocationImposter.Throws((TSource source) =>
                    {
                        throw exceptionGenerator.Invoke(source);
                    });
                    return this;
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroupCallback<TSource, TResult>.Callback(MapCallbackDelegate<TSource, TResult> callback)
                {
                    _currentInvocationImposter.Callback(callback);
                    return this;
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroup<TSource, TResult>.Returns(MapDelegate<TSource, TResult> resultGenerator)
                {
                    _currentInvocationImposter.Returns(resultGenerator);
                    return this;
                }

                IMapMethodInvocationImposterGroupContinuation<TSource, TResult> IMapMethodInvocationImposterGroup<TSource, TResult>.Returns(TResult value)
                {
                    _currentInvocationImposter.Returns(value);
                    return this;
                }

                IMapMethodInvocationImposterGroup<TSource, TResult> IMapMethodInvocationImposterGroupContinuation<TSource, TResult>.Then()
                {
                    this._currentInvocationImposter = _invocationImposterGroup.AddInvocationImposter();
                    return this;
                }

                void MapInvocationVerifier<TSource, TResult>.Called(global::Imposter.Abstractions.Count count)
                {
                    var invocationCount = _mapMethodInvocationHistoryCollection.Count<TSource, TResult>(_argumentsCriteria);
                    if (!count.Matches(invocationCount))
                    {
                        throw new global::Imposter.Abstractions.VerificationFailedException(count, invocationCount);
                    }
                }
            }
        }

        // TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)
        public delegate TArg TransformDelegate<TArg>(T input);
        // TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)
        public delegate void TransformCallbackDelegate<TArg>(T input);
        // TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)
        public delegate global::System.Exception TransformExceptionGeneratorDelegate<TArg>(T input);
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class TransformArguments<TArg>
        {
            public T input;
            internal TransformArguments(T input)
            {
                this.input = input;
            }

            public TransformArguments<TArgTarget> As<TArgTarget>()
            {
                return new TransformArguments<TArgTarget>(TypeCaster.Cast<T, T>(input));
            }
        }

        // TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)
        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public class TransformArgumentsCriteria<TArg>
        {
            public global::Imposter.Abstractions.Arg<T> input { get; }

            public TransformArgumentsCriteria(global::Imposter.Abstractions.Arg<T> input)
            {
                this.input = input;
            }

            public bool Matches(TransformArguments<TArg> arguments)
            {
                return input.Matches(arguments.input);
            }

            public TransformArgumentsCriteria<TArgTarget> As<TArgTarget>()
            {
                return new TransformArgumentsCriteria<TArgTarget>(global::Imposter.Abstractions.Arg<T>.Is(it => global::Imposter.Abstractions.TypeCaster.TryCast<T, T>(it, out T inputTarget) && input.Matches(inputTarget)));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface ITransformMethodInvocationHistory
        {
            bool Matches<TArgTarget>(TransformArgumentsCriteria<TArgTarget> criteria);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class TransformMethodInvocationHistory<TArg> : ITransformMethodInvocationHistory
        {
            internal TransformArguments<TArg> Arguments;
            internal TArg? Result;
            internal global::System.Exception? Exception;
            public TransformMethodInvocationHistory(TransformArguments<TArg> Arguments, TArg? Result, global::System.Exception? Exception)
            {
                this.Arguments = Arguments;
                this.Result = Result;
                this.Exception = Exception;
            }

            public bool Matches<TArgTarget>(TransformArgumentsCriteria<TArgTarget> criteria)
            {
                return ((typeof(T) == typeof(T)) && (typeof(TArg) == typeof(TArgTarget))) && criteria.As<TArg>().Matches(Arguments);
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class TransformMethodInvocationHistoryCollection
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<ITransformMethodInvocationHistory> _invocationHistory = new global::System.Collections.Concurrent.ConcurrentStack<ITransformMethodInvocationHistory>();
            internal void Add(ITransformMethodInvocationHistory invocationHistory)
            {
                _invocationHistory.Push(invocationHistory);
            }

            internal int Count<TArg>(TransformArgumentsCriteria<TArg> argumentsCriteria)
            {
                return _invocationHistory.Count(it => it.Matches<TArg>(argumentsCriteria));
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class TransformMethodImposterCollection
        {
            private readonly TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public TransformMethodImposterCollection(TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._transformMethodInvocationHistoryCollection = _transformMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            private readonly global::System.Collections.Concurrent.ConcurrentStack<ITransformMethodImposter> _imposters = new global::System.Collections.Concurrent.ConcurrentStack<ITransformMethodImposter>();
            internal TransformMethodImposter<TArg> AddNew<TArg>()
            {
                var imposter = new TransformMethodImposter<TArg>(_transformMethodInvocationHistoryCollection, _invocationBehavior);
                _imposters.Push(imposter);
                return imposter;
            }

            internal ITransformMethodImposter<TArg> GetImposterWithMatchingInvocationImposterGroup<TArg>(TransformArguments<TArg> arguments)
            {
                return _imposters.Select(it => it.As<TArg>()).Where(it => it != null).Select(it => it!).FirstOrDefault(it => it.HasMatchingInvocationImposterGroup(arguments)) ?? AddNew<TArg>();
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        class TransformMethodInvocationImposterGroup<TArg>
        {
            internal static TransformMethodInvocationImposterGroup<TArg> Default = new TransformMethodInvocationImposterGroup<TArg>(new TransformArgumentsCriteria<TArg>(global::Imposter.Abstractions.Arg<T>.Any()));
            internal TransformArgumentsCriteria<TArg> ArgumentsCriteria { get; }

            private readonly global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentQueue<MethodInvocationImposter>();
            private MethodInvocationImposter? _lastestInvocationImposter;
            public TransformMethodInvocationImposterGroup(TransformArgumentsCriteria<TArg> argumentsCriteria)
            {
                ArgumentsCriteria = argumentsCriteria;
            }

            internal MethodInvocationImposter AddInvocationImposter()
            {
                MethodInvocationImposter invocationImposter = new MethodInvocationImposter();
                _invocationImposters.Enqueue(invocationImposter);
                return invocationImposter;
            }

            private MethodInvocationImposter? GetInvocationImposter()
            {
                if (_invocationImposters.TryDequeue(out var invocationImposter))
                {
                    if (!invocationImposter.IsEmpty)
                    {
                        _lastestInvocationImposter = invocationImposter;
                    }

                    return invocationImposter;
                }

                return _lastestInvocationImposter;
            }

            public TArg Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, T input)
            {
                var invocationImposter = GetInvocationImposter();
                if (invocationImposter == null)
                {
                    if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                    }

                    invocationImposter = MethodInvocationImposter.Default;
                }

                return invocationImposter.Invoke(invocationBehavior, methodDisplayName, input);
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class MethodInvocationImposter
            {
                internal static MethodInvocationImposter Default;
                static MethodInvocationImposter()
                {
                    Default = new MethodInvocationImposter();
                    Default.Returns(DefaultResultGenerator);
                }

                private TransformDelegate<TArg>? _resultGenerator;
                private readonly global::System.Collections.Concurrent.ConcurrentQueue<TransformCallbackDelegate<TArg>> _callbacks = new global::System.Collections.Concurrent.ConcurrentQueue<TransformCallbackDelegate<TArg>>();
                internal bool IsEmpty => (_resultGenerator == null) && (_callbacks.Count == 0);

                public TArg Invoke(global::Imposter.Abstractions.ImposterMode invocationBehavior, string methodDisplayName, T input)
                {
                    if (_resultGenerator == null)
                    {
                        if (invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                        {
                            throw new global::Imposter.Abstractions.MissingImposterException(methodDisplayName);
                        }

                        _resultGenerator = DefaultResultGenerator;
                    }

                    TArg result = _resultGenerator.Invoke(input);
                    foreach (var callback in _callbacks)
                    {
                        callback(input);
                    }

                    return result;
                }

                internal void Callback(TransformCallbackDelegate<TArg> callback)
                {
                    _callbacks.Enqueue(callback);
                }

                internal void Returns(TransformDelegate<TArg> resultGenerator)
                {
                    _resultGenerator = resultGenerator;
                }

                internal void Returns(TArg value)
                {
                    _resultGenerator = (T input) =>
                    {
                        return value;
                    };
                }

                internal void Throws(TransformExceptionGeneratorDelegate<TArg> exceptionGenerator)
                {
                    _resultGenerator = (T input) =>
                    {
                        throw exceptionGenerator(input);
                    };
                }

                internal static TArg DefaultResultGenerator(T input)
                {
                    return default !;
                }
            }
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface ITransformMethodInvocationImposterGroupCallback<TArg>
        {
            ITransformMethodInvocationImposterGroupContinuation<TArg> Callback(TransformCallbackDelegate<TArg> callback);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface ITransformMethodInvocationImposterGroupContinuation<TArg> : ITransformMethodInvocationImposterGroupCallback<TArg>
        {
            ITransformMethodInvocationImposterGroup<TArg> Then();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface ITransformMethodInvocationImposterGroup<TArg> : ITransformMethodInvocationImposterGroupCallback<TArg>
        {
            ITransformMethodInvocationImposterGroupContinuation<TArg> Throws<TException>()
                where TException : global::System.Exception, new();
            ITransformMethodInvocationImposterGroupContinuation<TArg> Throws(global::System.Exception exception);
            ITransformMethodInvocationImposterGroupContinuation<TArg> Throws(TransformExceptionGeneratorDelegate<TArg> exceptionGenerator);
            ITransformMethodInvocationImposterGroupContinuation<TArg> Returns(TransformDelegate<TArg> resultGenerator);
            ITransformMethodInvocationImposterGroupContinuation<TArg> Returns(TArg value);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface ITransformMethodImposter
        {
            ITransformMethodImposter<TArgTarget>? As<TArgTarget>();
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal interface ITransformMethodImposter<TArg> : ITransformMethodImposter
        {
            TArg Invoke(T input);
            bool HasMatchingInvocationImposterGroup(TransformArguments<TArg> arguments);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface TransformInvocationVerifier<TArg>
        {
            void Called(Count count);
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        public interface ITransformMethodImposterBuilder<TArg> : ITransformMethodInvocationImposterGroup<TArg>, ITransformMethodInvocationImposterGroupCallback<TArg>, TransformInvocationVerifier<TArg>
        {
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        internal class TransformMethodImposter<TArg> : ITransformMethodImposter<TArg>
        {
            private readonly global::System.Collections.Concurrent.ConcurrentStack<TransformMethodInvocationImposterGroup<TArg>> _invocationImposters = new global::System.Collections.Concurrent.ConcurrentStack<TransformMethodInvocationImposterGroup<TArg>>();
            private readonly TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection;
            private readonly global::Imposter.Abstractions.ImposterMode _invocationBehavior;
            public TransformMethodImposter(TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection, global::Imposter.Abstractions.ImposterMode _invocationBehavior)
            {
                this._transformMethodInvocationHistoryCollection = _transformMethodInvocationHistoryCollection;
                this._invocationBehavior = _invocationBehavior;
            }

            ITransformMethodImposter<TArgTarget>? ITransformMethodImposter.As<TArgTarget>()
            {
                if (typeof(TArg).IsAssignableTo(typeof(TArgTarget)))
                {
                    return new Adapter<TArgTarget>(this);
                }

                return null;
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            private class Adapter<TArgTarget> : ITransformMethodImposter<TArgTarget>
            {
                private readonly TransformMethodImposter<TArg> _target;
                public Adapter(TransformMethodImposter<TArg> target)
                {
                    _target = target;
                }

                public TArgTarget Invoke(T input)
                {
                    var result = _target.Invoke(global::Imposter.Abstractions.TypeCaster.Cast<T, T>(input));
                    return global::Imposter.Abstractions.TypeCaster.Cast<TArg, TArgTarget>(result);
                }

                public bool HasMatchingInvocationImposterGroup(TransformArguments<TArgTarget> arguments)
                {
                    return _target.HasMatchingInvocationImposterGroup(arguments.As<TArg>());
                }

                ITransformMethodImposter<TArgTarget1>? ITransformMethodImposter.As<TArgTarget1>()
                {
                    throw new NotImplementedException();
                }
            }

            public bool HasMatchingInvocationImposterGroup(TransformArguments<TArg> arguments)
            {
                return FindMatchingInvocationImposterGroup(arguments) != null;
            }

            private TransformMethodInvocationImposterGroup<TArg>? FindMatchingInvocationImposterGroup(TransformArguments<TArg> arguments)
            {
                foreach (var invocationImposterGroup in _invocationImposters)
                {
                    if (invocationImposterGroup.ArgumentsCriteria.Matches(arguments))
                        return invocationImposterGroup;
                }

                return null;
            }

            public TArg Invoke(T input)
            {
                var arguments = new TransformArguments<TArg>(input);
                var matchingInvocationImposterGroup = FindMatchingInvocationImposterGroup(arguments);
                if (matchingInvocationImposterGroup == default)
                {
                    if (_invocationBehavior == global::Imposter.Abstractions.ImposterMode.Explicit)
                    {
                        throw new global::Imposter.Abstractions.MissingImposterException("TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)");
                    }

                    matchingInvocationImposterGroup = TransformMethodInvocationImposterGroup<TArg>.Default;
                }

                try
                {
                    var result = matchingInvocationImposterGroup.Invoke(_invocationBehavior, "TArg IOpenGenericWithMethodGenerics<T>.Transform<TArg>(T input)", input);
                    _transformMethodInvocationHistoryCollection.Add(new TransformMethodInvocationHistory<TArg>(arguments, result, default));
                    return result;
                }
                catch (global::System.Exception ex)
                {
                    _transformMethodInvocationHistoryCollection.Add(new TransformMethodInvocationHistory<TArg>(arguments, default, ex));
                    throw;
                }
            }

            [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
            internal class Builder : ITransformMethodImposterBuilder<TArg>, ITransformMethodInvocationImposterGroupContinuation<TArg>
            {
                private readonly TransformMethodImposterCollection _imposterCollection;
                private readonly TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection;
                private readonly TransformArgumentsCriteria<TArg> _argumentsCriteria;
                private readonly TransformMethodInvocationImposterGroup<TArg> _invocationImposterGroup;
                private TransformMethodInvocationImposterGroup<TArg>.MethodInvocationImposter _currentInvocationImposter;
                public Builder(TransformMethodImposterCollection _imposterCollection, TransformMethodInvocationHistoryCollection _transformMethodInvocationHistoryCollection, TransformArgumentsCriteria<TArg> _argumentsCriteria)
                {
                    this._imposterCollection = _imposterCollection;
                    this._transformMethodInvocationHistoryCollection = _transformMethodInvocationHistoryCollection;
                    this._argumentsCriteria = _argumentsCriteria;
                    this._invocationImposterGroup = new TransformMethodInvocationImposterGroup<TArg>(_argumentsCriteria);
                    TransformMethodImposter<TArg> methodImposter = _imposterCollection.AddNew<TArg>();
                    methodImposter._invocationImposters.Push(_invocationImposterGroup);
                    this._currentInvocationImposter = this._invocationImposterGroup.AddInvocationImposter();
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroup<TArg>.Throws<TException>()
                {
                    _currentInvocationImposter.Throws((T input) =>
                    {
                        throw new TException();
                    });
                    return this;
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroup<TArg>.Throws(global::System.Exception exception)
                {
                    _currentInvocationImposter.Throws((T input) =>
                    {
                        throw exception;
                    });
                    return this;
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroup<TArg>.Throws(TransformExceptionGeneratorDelegate<TArg> exceptionGenerator)
                {
                    _currentInvocationImposter.Throws((T input) =>
                    {
                        throw exceptionGenerator.Invoke(input);
                    });
                    return this;
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroupCallback<TArg>.Callback(TransformCallbackDelegate<TArg> callback)
                {
                    _currentInvocationImposter.Callback(callback);
                    return this;
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroup<TArg>.Returns(TransformDelegate<TArg> resultGenerator)
                {
                    _currentInvocationImposter.Returns(resultGenerator);
                    return this;
                }

                ITransformMethodInvocationImposterGroupContinuation<TArg> ITransformMethodInvocationImposterGroup<TArg>.Returns(TArg value)
                {
                    _currentInvocationImposter.Returns(value);
                    return this;
                }

                ITransformMethodInvocationImposterGroup<TArg> ITransformMethodInvocationImposterGroupContinuation<TArg>.Then()
                {
                    this._currentInvocationImposter = _invocationImposterGroup.AddInvocationImposter();
                    return this;
                }

                void TransformInvocationVerifier<TArg>.Called(global::Imposter.Abstractions.Count count)
                {
                    var invocationCount = _transformMethodInvocationHistoryCollection.Count<TArg>(_argumentsCriteria);
                    if (!count.Matches(invocationCount))
                    {
                        throw new global::Imposter.Abstractions.VerificationFailedException(count, invocationCount);
                    }
                }
            }
        }

        public IOpenGenericWithMethodGenericsImposter(global::Imposter.Abstractions.ImposterMode invocationBehavior = global::Imposter.Abstractions.ImposterMode.Implicit)
        {
            this._doSomethingMethodImposterCollection = new DoSomethingMethodImposterCollection(_doSomethingMethodInvocationHistoryCollection, invocationBehavior);
            this._transformMethodImposterCollection = new TransformMethodImposterCollection(_transformMethodInvocationHistoryCollection, invocationBehavior);
            this._mapMethodImposterCollection = new MapMethodImposterCollection(_mapMethodInvocationHistoryCollection, invocationBehavior);
            this._imposterInstance = new ImposterTargetInstance(this);
            this._invocationBehavior = invocationBehavior;
        }

        [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
        class ImposterTargetInstance : global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenerics<T>
        {
            private readonly IOpenGenericWithMethodGenericsImposter<T> _imposter;
            public ImposterTargetInstance(IOpenGenericWithMethodGenericsImposter<T> _imposter)
            {
                this._imposter = _imposter;
            }

            public void DoSomething<TArg>(TArg arg)
            {
                _imposter._doSomethingMethodImposterCollection.GetImposterWithMatchingInvocationImposterGroup<TArg>(new DoSomethingArguments<TArg>(arg)).Invoke(arg);
            }

            public TArg Transform<TArg>(T input)
            {
                return _imposter._transformMethodImposterCollection.GetImposterWithMatchingInvocationImposterGroup<TArg>(new TransformArguments<TArg>(input)).Invoke(input);
            }

            public TResult Map<TSource, TResult>(TSource source)
            {
                return _imposter._mapMethodImposterCollection.GetImposterWithMatchingInvocationImposterGroup<TSource, TResult>(new MapArguments<TSource, TResult>(source)).Invoke(source);
            }
        }
    }

    [global::System.CodeDom.Compiler.GeneratedCode("Imposter.CodeGenerator", "0.1.0.0")]
    public static class IOpenGenericWithMethodGenericsImposterExtensions
    {
        extension<T>(global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenerics<T> imposter)
        {
            public static global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenericsImposter<T> Imposter() => new global::Imposter.Tests.Features.OpenGenericImposter.IOpenGenericWithMethodGenericsImposter<T>();
        }
    }
}
#nullable restore
#pragma warning restore
