{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>Imposter \u2014 Source-generated test doubles/mocks/imposters, zero runtime overhead.</p>"},{"location":"#installation","title":"Installation","text":"<p>Add the packages to your test or application project:</p> <pre><code>dotnet add package Imposter\n</code></pre> <p>This package includes both the source generator (analyzer) and the runtime abstractions.</p> <p>Pro tip</p> <p>To inspect generated sources locally, set <code>EmitCompilerGeneratedFiles</code> and <code>CompilerGeneratedFilesOutputPath</code> in your project. Remove these before committing. <pre><code>&lt;!-- Source code generation settings--&gt;\n&lt;PropertyGroup&gt;\n    &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;\n    &lt;CompilerGeneratedFilesOutputPath&gt;GeneratedFiles&lt;/CompilerGeneratedFilesOutputPath&gt;\n&lt;/PropertyGroup&gt;\n\n&lt;!-- Include but don't compile generated code. The system will already compile the code, but this will make it visible for reference.--&gt;\n&lt;ItemGroup&gt;\n    &lt;Compile Remove=\"GeneratedFiles\\**\"/&gt;\n    &lt;None Include=\"GeneratedFiles\\**\"/&gt;\n&lt;/ItemGroup&gt;\n</code></pre></p>"},{"location":"#generate-an-imposter","title":"Generate an Imposter","text":"<p>Annotate the target type with the assembly level attribute and build. The generator produces a <code>&lt;TypeName&gt;Imposter</code> you can new up in code.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(IMyService))]\n\npublic interface IMyService\n{\n    int GetNumber();\n    int Increment(int value);\n    event EventHandler SomethingHappened;\n    int this[int key] { get; set; }\n}\n</code></pre> <p>After a build, use the generated type:</p> C# 14C# 8-13 <pre><code>var imposter = IMyService.Imposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <p>Use the generated imposter type directly:</p> <pre><code>var imposter = new IMyServiceImposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <p>Generate imposter for classes</p> <p>Warning</p> <p>Only non-sealed classes can be impersonated.</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(BaseService))]\n\npublic abstract class BaseService\n{\n    public virtual int GetNumber() =&gt; 0;\n}\n</code></pre> <p>After a build, use the generated type:</p> C# 14C# 8-13 <pre><code>var imposter = BaseService.Imposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <pre><code>var imposter = new BaseServiceImposter();\nimposter.GetNumber().Returns(42);\n\nvar service = imposter.Instance();\nservice.GetNumber().ShouldBe(42);\n</code></pre> <p>Note</p> <p>For classes, only virtual or abstract members can be impersonated (mocked).</p> <p>Warning</p> <p>Minimum supported C# version is 8.0</p> <p>Next steps</p> <ul> <li>Methods</li> <li>Properties</li> <li>Indexers</li> <li>Events</li> <li>Key API Reference</li> <li>Compatibility</li> <li>Limitations</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Overview of performance measurements using BenchmarkDotNet. The suite compares Imposter with popular mocking libraries for common setup and invocation patterns.</p>"},{"location":"benchmarks/#whats-measured","title":"What\u2019s Measured","text":"<ul> <li>Setup throughput: configuring return values for a simple method.</li> <li>Invocation throughput: calling the configured method.</li> <li>Parameterized iterations: 1, 10, 100, 1000 setups + calls.</li> </ul> <p>Primary scenario (see <code>ImposterVsOthersBenchmark.cs</code>):</p> <pre><code>public interface ICalculator { int Square(int input); }\n// Benchmarks compare: Imposter vs Moq vs NSubstitute\n</code></pre> <p>Additional microbenchmarks cover generator internals (syntax builders) and struct behaviors.</p>"},{"location":"benchmarks/#benchmark-results","title":"Benchmark Results","text":"<pre><code>BenchmarkDotNet v0.15.2, Windows 11 (10.0.26200.6899)\n13th Gen Intel Core i9-13900HX 2.20GHz, 1 CPU, 32 logical and 24 physical cores\n.NET SDK 10.0.100-rc.2.25502.107\n  [Host]     : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX2\n  DefaultJob : .NET 9.0.9 (9.0.925.41916), X64 RyuJIT AVX2\n\n\n| Method   | Iteration | Mean            | Error           | StdDev          | Gen0      | Gen1      | Gen2     | Allocated   |\n|--------- |---------- |----------------:|----------------:|----------------:|----------:|----------:|---------:|------------:|\n| Mock     | 1         |     57,888.4 ns |     1,152.97 ns |     1,861.83 ns |    0.6104 |    0.4883 |        - |    13.06 KB |\n| NSub     | 1         |      1,792.1 ns |        35.42 ns |        48.48 ns |    0.4120 |         - |        - |     7.73 KB |\n| Imposter | 1         |        187.8 ns |         3.41 ns |         3.02 ns |    0.1304 |    0.0010 |        - |      2.4 KB |\n| Mock     | 10        |    561,381.0 ns |     9,870.99 ns |     8,750.38 ns |    5.8594 |    4.8828 |        - |    115.8 KB |\n| NSub     | 10        |     11,091.9 ns |       220.34 ns |       506.26 ns |    1.5869 |         - |        - |    29.18 KB |\n| Imposter | 10        |      1,897.5 ns |        25.95 ns |        23.01 ns |    1.2169 |    0.0877 |        - |    22.37 KB |\n| Mock     | 100       |  5,659,959.7 ns |   106,879.17 ns |    89,248.95 ns |   62.5000 |   46.8750 |        - |  1417.69 KB |\n| NSub     | 100       |    317,054.3 ns |     5,962.06 ns |     5,576.92 ns |   13.1836 |    4.3945 |        - |   247.15 KB |\n| Imposter | 100       |     34,266.0 ns |       658.78 ns |       809.04 ns |   12.0239 |    5.6152 |        - |   222.05 KB |\n| Mock     | 1000      | 87,595,090.5 ns | 1,733,629.98 ns | 1,536,817.82 ns | 2000.0000 | 1000.0000 | 666.6667 | 42282.98 KB |\n| NSub     | 1000      | 25,822,022.4 ns |   513,318.30 ns |   630,401.02 ns |  125.0000 |   62.5000 |        - |  2420.71 KB |\n| Imposter | 1000      |  2,635,074.0 ns |    51,717.64 ns |    61,566.17 ns |  117.1875 |  101.5625 |        - |  2218.93 KB |\n</code></pre>"},{"location":"benchmarks/#run-locally","title":"Run Locally","text":"<pre><code>dotnet run -c Release -p benchmarks/Imposter.Benchmarks/Imposter.Benchmarks.csproj\n</code></pre> <p>BenchmarkDotNet will emit results under <code>benchmarks/Imposter.Benchmarks/BenchmarkDotNet.Artifacts/</code> (Markdown, CSV, and summary files).</p> <p>Pro tip</p> <ul> <li>Run in <code>Release</code> without the debugger attached for consistent results.</li> <li>Close background workloads and pin your .NET SDK version.</li> <li>Compare mean time and allocated bytes; prefer allocation-free setups where possible.</li> </ul>"},{"location":"benchmarks/#contributing-results","title":"Contributing Results","text":"<ul> <li>Run the suite, then add a brief summary of your findings here (date, runtime, CPU) if you want to share representative snapshots.</li> <li>For detailed tables, link to the generated Markdown in <code>BenchmarkDotNet.Artifacts/results</code> or paste selected rows.</li> </ul> <p>See also: Why Imposter?</p>"},{"location":"cheat-sheet/","title":"Cheat Sheet","text":"<p>Quick reference for common operations.</p>"},{"location":"cheat-sheet/#create-imposter","title":"Create Imposter","text":"<pre><code>// C# 14+\nvar imp = IMyService.Imposter();\nvar svc = imp.Instance();\n\n// C# 8\u201313\nvar imp2 = new IMyServiceImposter();\nvar svc2 = imp2.Instance();\n</code></pre>"},{"location":"cheat-sheet/#mode","title":"Mode","text":"<pre><code>var implicitImposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar explicitImposter = new IMyServiceImposter(ImposterMode.Explicit);\n</code></pre>"},{"location":"cheat-sheet/#methods","title":"Methods","text":"<pre><code>// Return values\nimp.GetNumber().Returns(42);\nimp.GetNumber().Returns(() =&gt; 42);\n\n// Sequencing\nimp.GetNumber().Returns(1).Then().Returns(2).Then().Throws&lt;InvalidOperationException&gt;();\n\n// Arguments\nimp.Increment(Arg&lt;int&gt;.Any()).Returns(v =&gt; v + 1);\nimp.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 10)).Returns(100);\nimp.Increment(5).Returns(50); // implicit Arg&lt;int&gt;\n\n// Ref/Out/In\nimp.GenericAllRefKind&lt;int, string, double, bool, int&gt;(OutArg&lt;int&gt;.Any(), Arg&lt;string&gt;.Any(), Arg&lt;double&gt;.Any(), Arg&lt;bool[]&gt;.Any())\n   .Returns((out int o, ref string r, in double d, bool[] a) =&gt; { o = 5; return 99; })\n   .Callback((out int o, ref string r, in double d, bool[] a) =&gt; { o = 5; });\n\n// Async\nimp.GetNumberAsync().ReturnsAsync(42);\nimp.DoWorkAsync().Returns(Task.CompletedTask);\n\n// Throw\nimp.GetNumber().Throws&lt;InvalidOperationException&gt;();\n\n// Verify\nsvc.Increment(1);\nimp.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(1));\n</code></pre>"},{"location":"cheat-sheet/#properties","title":"Properties","text":"<pre><code>imp.Age.Getter().Returns(33);\nimp.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt; { });\nimp.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.Once());\n</code></pre>"},{"location":"cheat-sheet/#indexers","title":"Indexers","text":"<pre><code>imp[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\nimp[Arg&lt;int&gt;.Any()].Setter().Callback((i, v) =&gt; { });\n</code></pre>"},{"location":"cheat-sheet/#events","title":"Events","text":"<pre><code>EventHandler h = (s, e) =&gt; { };\nsvc.SomethingHappened += h;\nimp.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\nimp.SomethingHappened.Raise(this, EventArgs.Empty);\n</code></pre>"},{"location":"cheat-sheet/#base-implementation","title":"Base Implementation","text":"<pre><code>imp.DoWork(Arg&lt;int&gt;.Any()).UseBaseImplementation();\nimp.Age.Getter().UseBaseImplementation();\n</code></pre>"},{"location":"compatibility/","title":"Compatibility Matrix","text":"<p>Imposter ships a single NuGet package (<code>Imposter</code>) containing the source generator (analyzer) and the runtime abstractions (<code>netstandard2.0</code>).</p> <p>Minimum supported C# language version is 8.0 for all target frameworks. Static type extensions (e.g., <code>IMyService.Imposter()</code>) are emitted only when compiling with C# 14 or later.</p> <p>Pro tip</p> <p>Enable static type extensions by setting <code>&lt;LangVersion&gt;14&lt;/LangVersion&gt;</code> (or <code>latest</code>) in your project. Otherwise, use the generated <code>FooImposter</code> type directly.</p>"},{"location":"compatibility/#matrix","title":"Matrix","text":"TFM Minimum C# Static type extensions Notes net9.0 8.0 Yes (C# 14+), otherwise No Works out-of-the-box with SDK projects and analyzers. net8.0 8.0 Yes (C# 14+), otherwise No Same capabilities as net9.0; set <code>&lt;LangVersion&gt;14&lt;/LangVersion&gt;</code> (or <code>latest</code>) to enable static type extensions. net6.0 8.0 Yes (C# 14+), otherwise No Ensure SDK-style project to load analyzers. Libraries consuming netstandard2.0 8.0 Yes (C# 14+), otherwise No Runtime ships as <code>netstandard2.0</code>; analyzer runs at build time."},{"location":"compatibility/#notes","title":"Notes","text":"<ul> <li>Static type extensions are a compile-time feature. If your project compiles with C# 8\u201313, use the generated <code>FooImposter</code> type directly. With C# 14+, you can use <code>Foo.Imposter()</code>.</li> <li>The generator requires SDK-style projects so analyzers load during build.</li> <li>The runtime library (<code>Imposter.Abstractions</code>) targets <code>netstandard2.0</code>, enabling broad runtime compatibility.</li> <li>For older tooling or non-SDK projects, migrate to SDK-style to use source generators.</li> </ul> <p>See also: Limitations.</p>"},{"location":"key-api-reference/","title":"Key API Reference","text":"<p>A compact list of the core types and fluent members you\u2019ll use most. This is not a full API surface \u2014 just the names and signatures you need to get productive.</p>"},{"location":"key-api-reference/#attribute","title":"Attribute","text":"<ul> <li><code>GenerateImposterAttribute</code></li> <li>Usage: <code>[assembly: Imposter.Abstractions.GenerateImposter(typeof(TTarget), bool putInTheSameNamespace = true)]</code></li> <li>Parameters:<ul> <li><code>Type type</code> \u2014 target interface or class</li> <li><code>bool putInTheSameNamespace = true</code> - try to place the generated imposter in the target's namespace</li> </ul> </li> </ul> <p>Pro tip</p> <p>Add the attribute at the assembly level in a single file to keep generation centralized and easy to audit.</p>"},{"location":"key-api-reference/#argument-matchers","title":"Argument Matchers","text":"<ul> <li><code>Arg&lt;T&gt;</code></li> <li><code>static Arg&lt;T&gt; Is(Func&lt;T, bool&gt; predicate)</code></li> <li><code>static Arg&lt;T&gt; Is(T? value)</code></li> <li><code>static Arg&lt;T&gt; Is(T? value, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsNot(Func&lt;T, bool&gt; predicate)</code></li> <li><code>static Arg&lt;T&gt; IsNot(T? value)</code></li> <li><code>static Arg&lt;T&gt; IsNot(T? value, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsIn(IEnumerable&lt;T&gt; values)</code></li> <li><code>static Arg&lt;T&gt; IsIn(IEnumerable&lt;T&gt; values, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsNotIn(IEnumerable&lt;T&gt; values)</code></li> <li><code>static Arg&lt;T&gt; IsNotIn(IEnumerable&lt;T&gt; values, IEqualityComparer&lt;T&gt; comparer)</code></li> <li><code>static Arg&lt;T&gt; IsDefault()</code></li> <li><code>static Arg&lt;T&gt; Any()</code></li> <li> <p><code>static implicit operator Arg&lt;T&gt;(T value)</code></p> </li> <li> <p><code>OutArg&lt;T&gt;</code></p> </li> <li><code>static OutArg&lt;T&gt; Any()</code> \u2014 wildcard for <code>out</code> parameters</li> </ul>"},{"location":"key-api-reference/#verification-counts","title":"Verification Counts","text":"<ul> <li><code>Count</code></li> <li><code>static Count Exactly(int count)</code></li> <li><code>static Count AtLeast(int count)</code></li> <li><code>static Count AtMost(int count)</code></li> <li><code>static Count Never()</code></li> <li><code>static Count Once()</code></li> <li><code>static readonly Count Any</code></li> </ul>"},{"location":"key-api-reference/#imposter-mode","title":"Imposter Mode","text":"<ul> <li><code>ImposterMode</code></li> <li><code>Implicit</code> \u2014 missing setups return defaults (loose)</li> <li><code>Explicit</code> \u2014 missing setups throw <code>MissingImposterException</code> (strict)</li> </ul>"},{"location":"key-api-reference/#method-setups-generated","title":"Method Setups (generated)","text":"<ul> <li>Typical fluent members on a method setup builder:</li> <li><code>Returns(TResult value)</code></li> <li><code>Returns(Func&lt;TResult&gt; factory)</code></li> <li><code>Returns(Func&lt;...parameters..., TResult&gt; factory)</code> \u2014 delegate receives in/ref/out/in params</li> <li><code>ReturnsAsync(TResult value)</code></li> <li><code>ReturnsAsync(Func&lt;Task&lt;TResult&gt;&gt; factory)</code></li> <li><code>Throws(Exception ex)</code></li> <li><code>Throws&lt;TException&gt;()</code></li> <li><code>Callback(Action action)</code> / <code>Callback(Action&lt;...parameters...&gt; action)</code></li> <li><code>Then()</code> \u2014 chain next behavior (return/throw/etc.) for subsequent matching calls</li> <li><code>Called(Count count)</code> \u2014 verify invocation frequency</li> </ul>"},{"location":"key-api-reference/#property-setups-generated","title":"Property Setups (generated)","text":"<ul> <li>Getter: <code>imposter.Property.Getter()</code> \u2192 supports <code>Returns(...)</code>, <code>Throws(...)</code>, <code>Callback(...)</code>, <code>Then()</code>, <code>Called(Count)</code></li> <li>Setter: <code>imposter.Property.Setter(Arg&lt;T&gt; valueMatcher)</code> \u2192 supports <code>Callback(...)</code>, <code>Called(Count)</code></li> <li>Base implementation: <code>UseBaseImplementation()</code> (when applicable for classes)</li> </ul> <p>Pro tip</p> <p>Do not edit generated <code>.g.cs</code> files. Change behavior via setups or generator inputs, then rebuild.</p>"},{"location":"key-api-reference/#indexer-setups-generated","title":"Indexer Setups (generated)","text":"<ul> <li>Indexer access: <code>imposter[Arg&lt;T1&gt;..., Arg&lt;TN&gt;...]</code></li> <li>Getter: <code>.Getter()</code> \u2192 <code>Returns(...)</code>, <code>Throws(...)</code>, <code>Callback(...)</code>, <code>Then()</code>, <code>Called(Count)</code></li> <li>Setter: <code>.Setter()</code> / <code>.Setter(Arg&lt;TValue&gt; valueMatcher)</code> \u2192 <code>Callback(...)</code>, <code>Called(Count)</code></li> <li>Base implementation: <code>UseBaseImplementation()</code></li> </ul>"},{"location":"key-api-reference/#event-helpers-generated","title":"Event Helpers (generated)","text":"<ul> <li>Raise: <code>imposter.Event.Raise(object? sender, EventArgs args)</code> (or concrete event args type)</li> <li>Verify:</li> <li><code>imposter.Event.Subscribed(Arg&lt;Delegate&gt;.Is(handler), Count count)</code></li> <li><code>imposter.Event.HandlerInvoked(Arg&lt;Delegate&gt;.Is(handler), Count count)</code></li> </ul> <p>See also: Cheat Sheet and Limitations.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>Imposter generates compile-time imposters. It does not alter existing types at runtime, so certain members and scenarios are out of scope.</p>"},{"location":"limitations/#what-you-can-target","title":"What You Can Target","text":"<ul> <li>Interfaces: fully supported.</li> <li>Classes: supported, but only overridable (virtual/abstract) members can be intercepted.</li> </ul>"},{"location":"limitations/#not-supported-out-of-scope","title":"Not Supported / Out of Scope","text":"<ul> <li>Non-virtual members on concrete classes</li> <li>Non-virtual instance methods, properties, indexers cannot be intercepted on non-abstract classes.</li> </ul> <p>Pro tip</p> <p>Wrap non-virtual members behind an interface or adapter. Generate an imposter for the adapter to keep tests fast and explicit.</p> <ul> <li>Static and extension methods</li> <li>Static methods/properties/fields and static classes are not mockable.</li> <li> <p>Extension methods are static calls; you cannot intercept the extension itself. Mock the underlying instance member instead.</p> </li> <li> <p>Sealed classes without virtuals</p> </li> <li> <p>Sealed types provide no override surface. If a sealed class exposes no virtual members, it cannot be intercepted.</p> </li> <li> <p>Private members</p> </li> <li> <p>Private members are not targetable. Imposters work against accessible members only (public/protected; <code>internal</code> when generated within the same assembly).</p> </li> <li> <p>Non-virtual events on classes</p> </li> <li>Events declared as non-virtual on classes cannot be intercepted; interface events are supported.</li> </ul>"},{"location":"limitations/#language-version-considerations","title":"Language Version Considerations","text":"<ul> <li>Static type extensions (e.g., <code>IMyService.Imposter()</code>) require C# 14+. On C# 8\u201313, use the generated <code>IMyServiceImposter</code> type directly.</li> </ul> <p>See also: Troubleshooting</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and quick fixes.</p>"},{"location":"troubleshooting/#type-does-not-contain-definition-imposter","title":"\"Type does not contain definition `Imposter'\"","text":"<ul> <li>Cause: static type extensions are generated only when compiling with C# 14 or later.</li> <li>Fix: set <code>&lt;LangVersion&gt;latest&lt;/LangVersion&gt;</code> (or <code>14.0</code>) in your project file, or use the generated imposter type directly (e.g., <code>new IMyServiceImposter()</code>).</li> </ul> <pre><code>&lt;PropertyGroup&gt;\n  &lt;LangVersion&gt;latest&lt;/LangVersion&gt;\n  &lt;!-- C# 14+ enables static type extensions; core functionality works on C# 8\u201313. --&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"troubleshooting/#missingimposterexception","title":"<code>MissingImposterException</code>","text":"<ul> <li>Cause: Explicit mode with no matching setup.</li> <li>Fix: add a setup for the invoked member or switch to Implicit mode.</li> </ul> <pre><code>// Add a setup\nimposter.DoWork(Arg&lt;int&gt;.Any()).Returns(0);\n\n// Or choose Implicit behavior\nvar imposter = new IMyServiceImposter(ImposterMode.Implicit);\n</code></pre>"},{"location":"troubleshooting/#generator-not-running-no-generated-files","title":"Generator not running / no generated files","text":"<ul> <li>Ensure the generator package is referenced and included as an analyzer (default with NuGet is fine).</li> <li>Verify the attribute usage is at assembly scope and the project builds successfully.</li> <li>In test projects, consider enabling emitted generated files for inspection.</li> </ul> <pre><code>&lt;PropertyGroup&gt;\n  &lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;\n  &lt;CompilerGeneratedFilesOutputPath&gt;GeneratedFiles&lt;/CompilerGeneratedFilesOutputPath&gt;\n  &lt;!-- For local inspection only; do not ship generated sources. --&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"troubleshooting/#refoutin-signatures-do-not-match","title":"Ref/Out/In signatures do not match","text":"<ul> <li>Cause: delegate signature must match the target method's ref/out/in modifiers exactly.</li> <li>Fix: ensure the types and modifiers align; use <code>OutArg&lt;T&gt;.Any()</code> for out parameters in setups.</li> </ul>"},{"location":"troubleshooting/#ambiguous-argument-matching","title":"Ambiguous argument matching","text":"<ul> <li>Cause: overlapping <code>Arg&lt;T&gt;</code> matchers cause multiple setups to match.</li> <li>Fix: choose more specific matchers or order your setups so the intended one is evaluated first.</li> </ul>"},{"location":"troubleshooting/#performance-under-concurrency","title":"Performance under concurrency","text":"<ul> <li>Imposters are designed and tested for thread-safety. If you observe contention, review setup patterns and prefer precomputed delegates over heavy per-call work.</li> </ul> <p>If issues persist, consult the tests under <code>tests/Imposter.Tests/Features/*</code> for working patterns.</p>"},{"location":"why-imposter/","title":"Why Imposter?","text":"<ul> <li>Source-generated test doubles, zero runtime overhead.</li> <li>Strong typing: fluent API matches your types and signatures, including ref/out/in and generics.</li> <li>Performance-conscious: lightweight shapes and allocation-aware design.</li> <li>Concurrency: stress-tested for thread-safety; sequencing preserves order.</li> <li>Coverage: methods, properties, indexers, and events with verification helpers.</li> <li>Ergonomics: <code>Arg&lt;T&gt;</code> matchers, <code>Count</code> verification, callbacks, sequencing.</li> </ul> <p>See benchmarks under <code>benchmarks/Imposter.Benchmarks</code> for comparisons with Moq and NSubstitute, and the on-site Benchmarks page for a summary and run instructions.</p> <p>Before adopting, review the Limitations to understand scope and constraints.</p>"},{"location":"events/","title":"Event Mocking","text":"<p>Imposter supports interface and class events with first-class APIs to subscribe/unsubscribe, raise, observe, and verify handler activity. Use this section to configure typical scenarios and understand edge cases like ordering and failures.</p>"},{"location":"events/#subscribeunsubscribe-verification","title":"Subscribe/Unsubscribe Verification","text":"<pre><code>EventHandler h = (s, e) =&gt; { };\n\nservice.SomethingHappened += h;\nservice.SomethingHappened -= h;\n\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\nimposter.SomethingHappened.Unsubscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n</code></pre>"},{"location":"events/#tips","title":"Tips","text":"<ul> <li>Prefer verifying subscription intent at the boundaries of your SUT (e.g., UI wire-up) rather than internals.</li> <li>Use <code>Arg&lt;EventHandler&gt;.Any()</code> when you want to assert subscription activity without caring about the exact delegate.</li> <li>For classes, events must be virtual/overridable to be intercepted; see Protected Events and Base Implementation.</li> </ul>"},{"location":"events/#raising","title":"Raising","text":"<pre><code>// Raise in-order for current subscribers\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\n</code></pre>"},{"location":"events/#semantics","title":"Semantics","text":"<ul> <li><code>Raise(sender, args)</code> notifies the handlers currently subscribed at the time of the call, in subscription order.</li> <li>If no one is subscribed, <code>Raise</code> is a no-op.</li> <li>Exceptions thrown by a handler bubble up and stop further handlers unless your SUT or test catches them (see Event Exceptions).</li> </ul> <p>Pro tip</p> <p>Ensure the SUT subscribes before raising. Use <code>Subscribed(...)</code> to make ordering expectations explicit when it matters.</p>"},{"location":"events/#interceptors-and-invocation-counts","title":"Interceptors and Invocation Counts","text":"<pre><code>// Observe subscriptions/unsubscriptions\nimposter.SomethingHappened.OnSubscribe(handler =&gt; { /* inspect */ });\nimposter.SomethingHappened.OnUnsubscribe(handler =&gt; { /* inspect */ });\n\n// Verify handler invocation count\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Exactly(2));\n</code></pre>"},{"location":"events/#additional-tips","title":"Additional Tips","text":"<ul> <li>Async scenarios are supported (see <code>EventImposter/AsyncTests.cs</code>). If your handlers are async <code>void</code> or return <code>Task</code>, prefer surfacing errors explicitly in tests.</li> <li>Thread-safety and ordering are validated in tests; avoid relying on handler side-effects for ordering-sensitive logic in production code.</li> <li>In Explicit mode, event subscription/raising does not require setups; verification still works the same.</li> </ul>"},{"location":"events/base-implementation/","title":"Base Implementation (Events)","text":"<p>Forwarding to a base event implementation applies only when the target class exposes an overridable event pattern that supports forwarding. Use this when your SUT relies on base accessors or when you want to exercise the real add/remove behavior.</p> <pre><code>// When supported on the target member\nimposter.SomethingHappened.UseBaseImplementation();\n\n// Subscriptions and raising flow through the class\u2019s event accessors\nEventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;  // forwards to class add accessor\nimposter.SomethingHappened.Raise(this, EventArgs.Empty); // invokes handlers maintained by base\n</code></pre> <p>Notes - Class targets only; interfaces do not have base event implementations. - Availability depends on whether the event accessors are overridable. - Works in both modes; verification (<code>Subscribed</code>, <code>Unsubscribed</code>, <code>HandlerInvoked</code>) still applies. - When enabled, subscribe/unsubscribe and raises flow through the target's accessors, preserving any custom logic in the base class (e.g., validation, deduplication, logging).</p> <p>See also: <code>tests/Imposter.Tests/Features/ClassImposter/AsyncEventsClassImposterTests.cs</code> and <code>tests/Imposter.Tests/Features/EventImposter/*</code>.</p>"},{"location":"events/callbacks-ordering/","title":"Callbacks &amp; Ordering","text":"<p>Attach callbacks and validate execution order. Method callbacks run after the configured <code>Returns</code>, allowing you to observe post-return side-effects.</p> <pre><code>var stages = new List&lt;string&gt;();\n\nimposter.GetNumber()\n    .Returns(() =&gt; { stages.Add(\"return\"); return 42; })\n    .Callback(() =&gt; stages.Add(\"first\"))\n    .Callback(() =&gt; stages.Add(\"second\"));\n\n// stages: [\"return\", \"first\", \"second\"]\n</code></pre>"},{"location":"events/callbacks-ordering/#events","title":"Events","text":"<p>Use similar patterns on events to track subscription changes or handler invocations. Interceptor hooks fire when the action occurs:</p> <pre><code>var subs = new List&lt;Delegate&gt;();\nimposter.SomethingHappened.OnSubscribe(h =&gt; subs.Add(h));\nimposter.SomethingHappened.OnUnsubscribe(h =&gt; subs.Remove(h));\n\nservice.SomethingHappened += (s,e) =&gt; {};\nservice.SomethingHappened -= (s,e) =&gt; {};\n\n// subs reflects current handler list\n</code></pre> <p>Raising calls handlers in subscription order.</p>"},{"location":"events/exceptions/","title":"Event Exceptions","text":"<p>Understand how exceptions interact with the event pipeline and how to assert failure paths.</p>"},{"location":"events/exceptions/#no-subscribers","title":"No subscribers","text":"<p>Raising with no subscribers is a no-op:</p> <pre><code>imposter.SomethingHappened.Raise(this, EventArgs.Empty); // does nothing\n</code></pre>"},{"location":"events/exceptions/#subscriber-throws","title":"Subscriber throws","text":"<p>If a subscribed handler throws, the exception bubbles up and subsequent handlers are not invoked unless the exception is caught by your code under test:</p> <pre><code>EventHandler boom = (s, e) =&gt; throw new InvalidOperationException(\"boom\");\nservice.SomethingHappened += boom;\n\nAssert.Throws&lt;InvalidOperationException&gt;(() =&gt; imposter.SomethingHappened.Raise(this, EventArgs.Empty));\n</code></pre> <p>If you want to continue invoking the remaining handlers even if one throws, catch exceptions in your code under test and make that behavior explicit.</p>"},{"location":"events/exceptions/#verification-failures","title":"Verification failures","text":"<p>Verification that doesn\u2019t meet expectations throws <code>VerificationFailedException</code> with explicit expected vs actual counts (see Verification docs for exact message format).</p> <p>See tests under <code>tests/Imposter.Tests/Features/EventImposter/ExceptionTests.cs</code>.</p>"},{"location":"events/imposter-modes/","title":"Imposter Modes (Events)","text":"<p>How event subscription and raising behave when you didn't set anything up.</p>"},{"location":"events/imposter-modes/#implicit-mode","title":"Implicit mode","text":"<p>Subscribing and unsubscribing just works; you don\u2019t need setups for handlers.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar service = imposter.Instance();\n\nEventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;\nservice.SomethingHappened -= h;\n\n// Verify subscribe/unsubscribe\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\nimposter.SomethingHappened.Unsubscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n\n// Raising with no subscribers is a no-op\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\n</code></pre>"},{"location":"events/imposter-modes/#explicit-mode","title":"Explicit mode","text":"<p>Subscriptions, unsubscriptions, and raising behave the same \u2014 no setup is required for the event pipeline. Explicit mode primarily affects other members (methods/properties) when missing setups are encountered.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Explicit);\nvar service = imposter.Instance();\n\nEventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n</code></pre>"},{"location":"events/imposter-modes/#interceptors","title":"Interceptors","text":"<p>Observe subscriptions and unsubscriptions in both modes:</p> <pre><code>imposter.SomethingHappened.OnSubscribe(handler =&gt; { /* inspect */ });\nimposter.SomethingHappened.OnUnsubscribe(handler =&gt; { /* inspect */ });\n</code></pre>"},{"location":"events/imposter-modes/#tips","title":"Tips","text":"<ul> <li>Choose Implicit for most tests; use Explicit to make unintended calls stand out in strict scenarios.</li> <li>Event verification (<code>Subscribed</code>, <code>Unsubscribed</code>, <code>HandlerInvoked</code>) works identically in both modes.</li> </ul> <p>See also: <code>tests/Imposter.Tests/Features/EventImposter/*</code>.</p>"},{"location":"events/protected-members/","title":"Protected Events","text":"<p>Configure protected virtual events on class targets and interact through public wrappers.</p>"},{"location":"events/protected-members/#subscriberaise-via-wrapper","title":"Subscribe/Raise via wrapper","text":"<pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual event EventHandler? ProtectedChanged;\n\n    public virtual void Subscribe(EventHandler h) =&gt; ProtectedChanged += h;\n    public virtual void Unsubscribe(EventHandler h) =&gt; ProtectedChanged -= h;\n}\n\nvar imp = new MyServiceImposter();\nvar svc = imp.Instance();\n\n// Forward wrapper methods to base accessors\nimp.Subscribe(Arg&lt;EventHandler&gt;.Any()).UseBaseImplementation();\nimp.Unsubscribe(Arg&lt;EventHandler&gt;.Any()).UseBaseImplementation();\n\n// Subscribe through the wrapper, then raise protected event\nvar called = false;\nsvc.Subscribe((s, e) =&gt; called = true);\nimp.ProtectedChanged.Raise(svc, EventArgs.Empty);\n// called == true\n</code></pre> <p>Notes - Class targets only; event accessors must be overridable. - Wrapper methods must be <code>virtual</code> to be configurable on the imposter. - Verify via <code>Subscribed</code>, <code>Unsubscribed</code>, and <code>HandlerInvoked</code> on the event builder. - Consider exposing a protected virtual <code>OnXxx(EventArgs e)</code> method in your design. Your SUT can call it directly; tests can verify <code>HandlerInvoked</code> without relying on wrapper indirection.</p>"},{"location":"events/raising/","title":"Raising","text":"<p>Raise events to invoke current subscribers. You can raise both <code>EventHandler</code> and <code>EventHandler&lt;T&gt;</code>-style events.</p> <pre><code>// Classic EventHandler\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\n\n// Generic EventHandler&lt;T&gt;\nimposter.DataReceived.Raise(this, new DataEventArgs(payload));\n</code></pre>"},{"location":"events/raising/#semantics","title":"Semantics","text":"<ul> <li>Notifies handlers in the order they subscribed.</li> <li>If there are no subscribers, the call is a no-op.</li> <li>Exceptions thrown by a handler will propagate and stop further handlers unless caught upstream.</li> <li>Works regardless of ImposterMode (Implicit/Explicit) \u2014 setups are not required for events.</li> </ul>"},{"location":"events/raising/#patterns","title":"Patterns","text":"<ul> <li>Verify a specific handler was invoked a certain number of times:</li> </ul> <pre><code>EventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;\n\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n</code></pre> <ul> <li>Verify any handler was invoked (count total invocations):</li> </ul> <pre><code>imposter.SomethingHappened.Raise(this, EventArgs.Empty);\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Any(), Count.Exactly(1));\n</code></pre>"},{"location":"events/raising/#async","title":"Async","text":"<p>If handlers are async (returning <code>Task</code>), the event shape is still <code>void</code> at the CLR level. Prefer surfacing completion and failures through your API under test, and assert via your test framework. See <code>EventImposter/AsyncTests.cs</code> for guidance.</p>"},{"location":"events/subscriptions/","title":"Subscriptions","text":"<p>Track and verify that handlers are added or removed as expected. Use argument matchers if you need to assert a specific delegate identity.</p> <pre><code>EventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;\nservice.SomethingHappened -= h;\n\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\nimposter.SomethingHappened.Unsubscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n</code></pre> <p>Observe changes as they occur:</p> <pre><code>imposter.SomethingHappened.OnSubscribe(handler =&gt; { /* inspect */ });\nimposter.SomethingHappened.OnUnsubscribe(handler =&gt; { /* inspect */ });\n</code></pre>"},{"location":"events/subscriptions/#semantics","title":"Semantics","text":"<ul> <li>Subscriptions are tracked per handler instance. If you subscribe the same delegate twice, you must unsubscribe twice.</li> <li><code>Subscribed</code>/<code>Unsubscribed</code> respect matchers. Use <code>Arg&lt;EventHandler&gt;.Any()</code> to count all subscribe/remove operations.</li> <li>Verification counts follow the same rules as methods; see Verification.</li> </ul>"},{"location":"events/subscriptions/#tips","title":"Tips","text":"<ul> <li>Keep handler references to make unsubscription clear and verifiable.</li> <li>For lambdas, assign them to a local variable so you can verify the same instance.</li> <li>In class targets, ensure event accessors are virtual to enable interception.</li> </ul>"},{"location":"events/verification/","title":"Event Verification","text":"<p>Verify handler subscriptions and invocations.</p> <pre><code>EventHandler h = (s, e) =&gt; { };\nservice.SomethingHappened += h;\nimposter.SomethingHappened.Subscribed(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n\nimposter.SomethingHappened.Raise(this, EventArgs.Empty);\nimposter.SomethingHappened.HandlerInvoked(Arg&lt;EventHandler&gt;.Is(h), Count.Once());\n</code></pre>"},{"location":"indexers/","title":"Indexer Mocking","text":"<p>Set up getter and setter behaviors for indexers, with argument matchers and base forwarding.</p>"},{"location":"indexers/#getter","title":"Getter","text":"<pre><code>// Match by predicate\nimposter[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\nvar value = service[123]; // 10\n</code></pre>"},{"location":"indexers/#setter","title":"Setter","text":"<pre><code>// Observe writes\nimposter[Arg&lt;int&gt;.Any()].Setter().Callback((index, v) =&gt; { /* side-effects */ });\n</code></pre> <p>Pro tip</p> <p>Prefer precise key matchers (e.g., <code>Is(k =&gt; k == 123)</code>) before adding broad <code>Any()</code> setups. This helps avoid ambiguity between overlapping indexer setups.</p>"},{"location":"indexers/#base-implementation","title":"Base Implementation","text":"<pre><code>imposter[Arg&lt;int&gt;.Any()].Getter().UseBaseImplementation();\nimposter[Arg&lt;int&gt;.Any()].Setter().UseBaseImplementation();\n</code></pre>"},{"location":"indexers/#tips","title":"Tips","text":"<ul> <li>Use <code>Arg&lt;T&gt;</code> matchers for index keys, including <code>Any</code>, <code>Is</code>, and collections.</li> <li>See tests under <code>tests/Imposter.Tests/Features/IndexerImposter/*</code> for thread-safety and multi-parameter scenarios.</li> </ul>"},{"location":"indexers/base-implementation/","title":"Indexer Base Implementation","text":"<p>Forward reads and writes to the base implementation for overridable class indexers.</p> <pre><code>imposter[Arg&lt;int&gt;.Any()].Getter().UseBaseImplementation();\nimposter[Arg&lt;int&gt;.Any()].Setter().UseBaseImplementation();\n</code></pre>"},{"location":"indexers/getter/","title":"Indexer Getter","text":"<p>Set up indexer reads using <code>Arg&lt;T&gt;</code> matchers.</p> <pre><code>imposter[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\nvar x = service[123]; // 10\n</code></pre> <p>Multi-parameter indexers are supported; match each argument:</p> <pre><code>imposter[Arg&lt;string&gt;.Any(), Arg&lt;int&gt;.Is(i =&gt; i &gt; 10)].Getter().Returns(5);\n</code></pre>"},{"location":"indexers/imposter-modes/","title":"Imposter Modes (Indexers)","text":"<p>How indexer reads and writes behave when you didn\u2019t set them up.</p>"},{"location":"indexers/imposter-modes/#implicit-mode","title":"Implicit mode","text":"<p>Getter without a setup returns default values.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar service = imposter.Instance();\n\n// Read without a setup =&gt; default(int) == 0\nint v = service[123]; // 0\n\n// Add a getter setup with a matcher\nimposter[Arg&lt;int&gt;.Is(k =&gt; k &gt; 0)].Getter().Returns(10);\nv = service[123]; // 10\n\n// Writes work without setups; verify writes\nservice[7] = 42;\nimposter[Arg&lt;int&gt;.Is(7)].Setter().Called(Count.Once());\n</code></pre>"},{"location":"indexers/imposter-modes/#explicit-mode","title":"Explicit mode","text":"<p>Getter without a setup throws so unintended reads are caught.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Explicit);\nvar service = imposter.Instance();\n\nAssert.Throws&lt;MissingImposterException&gt;(() =&gt; { var _ = service[5]; });\n\nimposter[Arg&lt;int&gt;.Any()].Getter().Returns(1);\nvar x = service[5]; // 1\n</code></pre>"},{"location":"indexers/imposter-modes/#calling-real-code-on-classes","title":"Calling real code on classes","text":"<p>Forward to the class\u2019s own implementation for overridable indexers:</p> <pre><code>imposter[Arg&lt;int&gt;.Any()].Getter().UseBaseImplementation();\nimposter[Arg&lt;int&gt;.Any()].Setter().UseBaseImplementation();\n</code></pre> <p>See also: <code>tests/Imposter.Tests/Features/IndexerImposter/*</code>.</p>"},{"location":"indexers/protected-members/","title":"Protected Indexers","text":"<p>Configure protected virtual indexers on class targets and access them through public wrappers.</p>"},{"location":"indexers/protected-members/#gettersetter-with-wrapper","title":"Getter/Setter with wrapper","text":"<pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual int this[int index]\n    {\n        get =&gt; index;\n        set { /* track */ }\n    }\n\n    public virtual int ReadProtected(int i) =&gt; this[i];\n    public virtual void WriteProtected(int i, int v) =&gt; this[i] = v;\n}\n\nvar imp = new MyServiceImposter();\n\n// Arrange getter via matcher\nimp[Arg&lt;int&gt;.Any()].Getter().Returns(i =&gt; i * 10);\n\n// Forward wrappers to base so they call the protected indexer\nimp.ReadProtected(Arg&lt;int&gt;.Any()).UseBaseImplementation();\nimp.WriteProtected(Arg&lt;int&gt;.Any(), Arg&lt;int&gt;.Any()).UseBaseImplementation();\n\nvar svc = imp.Instance();\nsvc.ReadProtected(3); // 30\n\nsvc.WriteProtected(7, 123);\nimp[Arg&lt;int&gt;.Is(7)].Setter().Called(Count.Once());\n</code></pre> <p>Notes - Class targets only; indexer must be overridable. - Wrapper methods must be <code>virtual</code> to be configurable on the imposter.</p>"},{"location":"indexers/setter/","title":"Indexer Setter","text":"<p>Observe writes and verify counts.</p> <pre><code>imposter[Arg&lt;int&gt;.Any()].Setter().Callback((index, value) =&gt;\n{\n    // record writes\n});\n\nservice[7] = 42;\nimposter[Arg&lt;int&gt;.Is(7)].Setter().Called(Count.Once());\n</code></pre>"},{"location":"indexers/verification/","title":"Indexer Verification","text":"<p>Use <code>Called</code> with <code>Count</code> to verify setter usage; combine getters with callbacks or count reads where applicable.</p>"},{"location":"indexers/verification/#semantics","title":"Semantics","text":"<ul> <li><code>imposter[...].Setter().Called(Count)</code> counts writes for indexers whose indices (and optional value matcher) satisfy the provided matchers.</li> <li><code>imposter[...].Getter().Called(Count)</code> counts reads for indexers whose indices satisfy the matchers.</li> <li>Count helpers have identical meaning as for methods/properties.</li> </ul> <pre><code>service[1] = 10;\nservice[2] = 20;\n\nimposter[Arg&lt;int&gt;.Any()].Setter().Called(Count.AtLeast(2));\nimposter[Arg&lt;int&gt;.Is(2)].Setter().Called(Count.Once());\n</code></pre>"},{"location":"indexers/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown with the message:</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\n</code></pre> <p>Example:</p> <pre><code>// Expected a single write to index 2, but none occurred\nimposter[Arg&lt;int&gt;.Is(2)].Setter().Called(Count.Once());\n// throws: \"Invocation was expected to be performed exactly 1 time(s) but instead was performed 0 times.\"\n</code></pre>"},{"location":"methods/","title":"Method Impersonation","text":"<p>Here we'll cover returns, async, exceptions, callbacks, sequencing, argument matching, ref/out/in parameters, base forwarding, verification, and concurrency notes.</p>"},{"location":"methods/#overview","title":"Overview","text":"<p>Generated imposters expose fluent method builders you can use to:</p> <ul> <li>Arrange outcomes: <code>Returns</code>, <code>ReturnsAsync</code>, <code>Throws</code></li> <li>Add side effects: <code>Callback</code></li> <li>Sequence behaviors: <code>Then</code></li> <li>Verify invocations: <code>Called(Count.*)</code></li> </ul> <p>Invocation modes:</p> <ul> <li><code>Implicit</code> (default): missing setups return default values and do nothing for void methods.</li> <li><code>Explicit</code>: missing setups throw <code>MissingImposterException</code>.</li> </ul> <p>Pro tip</p> <p>Use <code>Explicit</code> mode for strict unit tests to fail fast on unintended calls. Keep <code>Implicit</code> for exploratory tests where defaults are acceptable.</p> <p>Imposter Modes</p> <p>See a deeper dive with examples in Imposter Modes.</p>"},{"location":"methods/#quick-start","title":"Quick Start","text":"<p>Define the target interface and enable generation:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IQuickStartService))]\n\npublic interface IQuickStartService\n{\n    int GetNumber();\n    int Increment(int v);\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n    System.Threading.Tasks.Task DoWorkAsync();\n    int Combine(int a, int b);\n    int VirtualCompute(int v);\n}\n</code></pre> <p>Example</p> <pre><code>var imposter = new IQuickStartServiceImposter();\nvar service = imposter.Instance();\n\nimposter.GetNumber().Returns(42);\nservice.GetNumber(); // 42\n\nimposter.Increment(Arg&lt;int&gt;.Any()).Returns(0);\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 0)).Returns(v =&gt; v + 2);\nimposter.Increment(5).Returns(50);          // exact match (implicit Arg&lt;int&gt;)\n</code></pre>"},{"location":"methods/#arranging-returns","title":"Arranging Returns","text":"<ul> <li>Return a constant value:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Returns(1);\n</code></pre> <ul> <li>Return via a delegate (captures inputs):</li> </ul> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any()).Returns(v =&gt; v + 2);\n</code></pre> <ul> <li>Sequence multiple outcomes with <code>Then()</code>:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Returns(() =&gt; 2)\n    .Then().Returns(3);\n</code></pre> <p>Note</p> <ul> <li>Use <code>Then()</code> to set up sequence.</li> <li>After a sequence is exhausted, the last outcome repeats (when applicable).</li> </ul>"},{"location":"methods/#async-methods","title":"Async Methods","text":"<ul> <li>Task and ValueTask methods: <p>Example</p> <pre><code>imposter.GetNumberAsync().ReturnsAsync(42);\nimposter.GetNumberAsync().Returns(() =&gt; Task.FromResult(1));\n</code></pre> <ul> <li>Task-returning (no result):</li> </ul> <p>Example</p> <pre><code>imposter.DoWorkAsync().Returns(Task.CompletedTask);\n</code></pre> <ul> <li>Sequencing remains the same:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumberAsync()\n    .ReturnsAsync(1)\n    .Then().Returns(() =&gt; Task.FromResult(2));\n</code></pre> <p>Pro tip</p> <p>Prefer <code>ReturnsAsync</code> for Task/ValueTask methods. It reads cleaner and avoids accidental sync-over-async in factories.</p>"},{"location":"methods/#exceptions","title":"Exceptions","text":"<p>Arrange exceptions instead of return values:</p> <p>Example</p> <pre><code>imposter.GetNumber().Throws&lt;InvalidOperationException&gt;();\nimposter.GetNumber().Throws(new Exception(\"boom\"));\nimposter.GetNumber().Throws(() =&gt; new Exception(\"deferred\"));\n</code></pre> <p>Mix with returns using <code>Then()</code>:</p> <p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Throws&lt;InvalidOperationException&gt;()\n    .Then().Returns(2);\n</code></pre>"},{"location":"methods/#callbacks","title":"Callbacks","text":"<p>Callbacks run after an outcome is produced (or after the default result for missing returns in Implicit mode):</p> <p>Example</p> <pre><code>var stages = new List&lt;string&gt;();\n\nimposter.GetNumber()\n    .Returns(() =&gt; { stages.Add(\"return\"); return 42; })\n    .Callback(() =&gt; stages.Add(\"first\"))\n    .Callback(() =&gt; stages.Add(\"second\"));\n</code></pre> <p>Parameterized callbacks capture inputs:</p> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any()).Callback(v =&gt; /* observe v */);\n</code></pre> <p>Sequence-local callbacks:</p> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any())\n    .Returns(_ =&gt; 10)\n    .Callback(_ =&gt; Log(\"first\"))\n    .Then()\n    .Returns(_ =&gt; 20)\n    .Callback(_ =&gt; Log(\"second\"));\n</code></pre>"},{"location":"methods/#argument-matching","title":"Argument Matching","text":"<p>Use precise values or matchers per parameter: - Exact value (implicit <code>Arg&lt;T&gt;</code>): <code>imposter.Increment(5)</code> - Any value: <code>Arg&lt;T&gt;.Any()</code> - Predicate: <code>Arg&lt;T&gt;.Is(x =&gt; x &gt; 10)</code> / negation: <code>Arg&lt;T&gt;.IsNot(...)</code> - Membership: <code>Arg&lt;T&gt;.IsIn(collection)</code> / <code>IsNotIn(collection)</code> - Default: <code>Arg&lt;T&gt;.IsDefault()</code></p> <p>Combine for multi-parameter methods:</p> <p>Example</p> <pre><code>imposter.Combine(\n    Arg&lt;int&gt;.Is(x =&gt; x &gt; 0),\n    Arg&lt;int&gt;.Is(y =&gt; y &lt; 10))\n  .Returns(42);\n</code></pre> <p>Pro tip</p> <p>Start with precise matchers (e.g., <code>Is(...)</code>) before adding broad <code>Any()</code> fallbacks. This reduces ambiguity between overlapping setups.</p>"},{"location":"methods/#refoutin-parameters","title":"Ref/Out/In Parameters","text":"<p>Use <code>OutArg&lt;T&gt;.Any()</code> to match <code>out</code> parameters; <code>Arg&lt;T&gt;</code> for <code>ref</code> and <code>in</code>.</p> <p>Returns and callbacks can specify <code>out/ref/in</code> in the delegate signature:</p> <p>Example</p> <pre><code>imposter.GenericAllRefKind&lt;int, string, double, bool, int&gt;(\n        OutArg&lt;int&gt;.Any(),\n        Arg&lt;string&gt;.Any(),\n        Arg&lt;double&gt;.Any(),\n        Arg&lt;bool[]&gt;.Any())\n    .Returns((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; return 99; })\n    .Callback((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; });\n</code></pre>"},{"location":"methods/#base-implementation-class-targets","title":"Base Implementation (Class Targets)","text":"<p>Info</p> <p><code>UseBaseImplementation()</code> applies only to non-abstract, virtual class members. It is not available for interfaces. See the dedicated page: Base Implementation.</p>"},{"location":"methods/#verification","title":"Verification","text":"<p>Use <code>Called(Count.*)</code> on the method to assert invocation counts:</p> <p>Example</p> <pre><code>// After calling service methods\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Increment(2).Called(Count.Once());\n</code></pre> <p>See more examples on GitHub. <code>Count</code> options: - <code>Exactly(n)</code>, <code>AtLeast(n)</code>, <code>AtMost(n)</code>, <code>Once()</code>, <code>Never()</code>, <code>Any</code></p> <p>If verification fails, a <code>VerificationFailedException</code> is thrown with a clear message.</p> <p>Pro tip</p> <p>Place verification at the end of the test. Verify the broad call first (e.g., <code>Any()</code>), then the specific one to keep failure messages focused.</p> <p>Next steps</p> <ul> <li>Deep dives for methods:</li> <li>Sequential Returns</li> <li>Throwing Exceptions</li> <li>Verification</li> <li>Callbacks</li> <li>Base Implementation</li> <li>Protected Methods</li> <li>Imposter Modes</li> </ul>"},{"location":"methods/#concurrency-notes","title":"Concurrency Notes","text":"<p>Sequenced outcomes are consumed in order under concurrency; the implementation avoids races that would otherwise reorder or drop planned outcomes. If a sequence is exhausted, the last outcome is repeated (when applicable) or default behavior applies.</p>"},{"location":"methods/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Repeating <code>Returns</code> or <code>Throws</code> without <code>Then()</code> is invalid.</li> <li>In <code>Explicit</code> mode, missing setups throw <code>MissingImposterException</code>.</li> <li>Ensure <code>OutArg&lt;T&gt;.Any()</code> is used for <code>out</code> parameters; use <code>Arg&lt;T&gt;</code> for <code>ref</code>/<code>in</code>.</li> </ul>"},{"location":"methods/base-implementation/","title":"Base Implementation (Methods)","text":"<p>Forward method calls to the class\u2019s own implementation when generating imposters for classes.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.MyService))]\n\npublic class MyService\n{\n    public virtual int Add(int a, int b) =&gt; a + b;\n    public virtual System.Threading.Tasks.Task ProcessAsync(string s) =&gt; System.Threading.Tasks.Task.CompletedTask;\n    public virtual int MightFail(int v) =&gt; throw new System.InvalidOperationException(\"fail\");\n}\n</code></pre>"},{"location":"methods/base-implementation/#when-it-applies","title":"When it applies","text":"<ul> <li>Class targets only. Interfaces don\u2019t have implementations to forward to.</li> <li>The member must be overridable (e.g., <code>virtual</code>/<code>protected virtual</code>). Sealed or non-virtual members can\u2019t be forwarded.</li> <li>Works in both modes:</li> <li>Implicit: the base method runs if you select <code>UseBaseImplementation()</code>.</li> <li>Explicit: the base method runs and no exception is thrown for that call.</li> </ul>"},{"location":"methods/base-implementation/#basic-example","title":"Basic example","text":"<p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/BaseImplementationTests.cs#L27\"}</p> <p>// Given a class target with an overridable method public class MyService {     public virtual int Add(int a, int b) =&gt; a + b; }</p> <p>[assembly: GenerateImposter(typeof(MyService))]</p> <p>var imp = new MyServiceImposter(); var svc = imp.Instance();</p> <p>// Forward calls to the original implementation imp.Add(Arg.Any(), Arg.Any()).UseBaseImplementation(); var sum = svc.Add(2, 5); // 7 (calls MyService.Add)     ```"},{"location":"methods/base-implementation/#with-matchers-and-sequencing","title":"With matchers and sequencing","text":"<p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/BaseImplementationTests.cs#L38\"}</p> <p>// Otherwise return a specific value (fallback) imp.Add(Arg.Any(), Arg.Any())    .Returns(-1); <p>// Only forward when the first value is positive (more specific rule) imp.Add(Arg.Is(x =&gt; x &gt; 0), Arg.Any()).UseBaseImplementation(); <p>svc.Add(2, 3);  // 5 (base) svc.Add(-2, 3); // -1     ```</p> <p>Sequence with <code>Then()</code> if you need to call base once and then switch behavior:</p> <p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/BaseImplementationTests.cs#L54\"}</p> <p>imp.Add(Arg.Any(), Arg.Any())    .UseBaseImplementation()    .Then()    .Returns(100); <p>svc.Add(1, 1); // base -&gt; 2 svc.Add(1, 1); // 100     ```</p>"},{"location":"methods/base-implementation/#async-and-refoutin-methods","title":"Async and ref/out/in methods","text":"<ul> <li>Async: forwarding respects the original <code>async</code> method (await the returned <code>Task</code>/<code>ValueTask</code>).</li> <li>Ref/out/in: signatures must match; you can still use <code>Arg&lt;T&gt;</code> and <code>OutArg&lt;T&gt;.Any()</code> in your setup and call base.</li> </ul> <p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/BaseImplementationTests.cs#L70\"}</p> <p>imp.ProcessAsync(Arg.Any()).UseBaseImplementation(); await svc.ProcessAsync(\"x\"); // runs class implementation     ```"},{"location":"methods/base-implementation/#exceptions-from-base","title":"Exceptions from base","text":"<p>If the base method throws, the exception flows to the caller. You can verify invocations using <code>Called(Count.*)</code> in either mode.</p> <p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/BaseImplementationTests.cs#L74\"}</p> <p>imp.MightFail(Arg.Any()).UseBaseImplementation(); Assert.Throws(() =&gt; svc.MightFail(5));     ``` <p>See more examples on GitHub.</p>"},{"location":"methods/callbacks/","title":"Method Callbacks","text":"<p>Callbacks run after the arranged result (or after the default result in Implicit mode when no <code>Returns</code> is provided).</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.ICallbackService))]\n\npublic interface ICallbackService\n{\n    int GetNumber();\n    int Increment(int v);\n    int GenericAllRefKind(out int o, ref string r, in double d, bool[] args);\n}\n</code></pre>"},{"location":"methods/callbacks/#ordering-relative-to-results","title":"Ordering relative to results","text":"<p>Example</p> <pre><code>var stages = new List&lt;string&gt;();\n\nimposter.GetNumber()\n    .Returns(() =&gt; { stages.Add(\"return\"); return 42; })\n    .Callback(() =&gt; stages.Add(\"first\"))\n    .Callback(() =&gt; stages.Add(\"second\"));\n\nservice.GetNumber();\n// stages == [\"return\", \"first\", \"second\"]\n</code></pre>"},{"location":"methods/callbacks/#parameterized-callbacks","title":"Parameterized callbacks","text":"<p>Capture input arguments in a callback:</p> <p>Example</p> <pre><code>imposter.Increment(Arg&lt;int&gt;.Any()).Callback(v =&gt; Logger.Log($\"value: {v}\"));\n</code></pre>"},{"location":"methods/callbacks/#refoutin-with-callbacks","title":"Ref/out/in with callbacks","text":"<p>Callbacks can work with <code>out</code>, <code>ref</code>, and <code>in</code> parameters. Use <code>OutArg&lt;T&gt;.Any()</code> to match <code>out</code> parameters in the setup signature.</p> <p>Example</p> <pre><code>imposter.GenericAllRefKind&lt;int, string, double, bool, int&gt;(\n        OutArg&lt;int&gt;.Any(),\n        Arg&lt;string&gt;.Any(),\n        Arg&lt;double&gt;.Any(),\n        Arg&lt;bool[]&gt;.Any())\n    .Returns((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; return 99; })\n    .Callback((out int o, ref string r, in double d, bool[] args) =&gt; { o = 5; /* side-effects */ });\n</code></pre>"},{"location":"methods/callbacks/#sequence-local-callbacks","title":"Sequence-local callbacks","text":"<p>Callbacks are scoped to the sequence step they\u2019re defined on. Use <code>Then()</code> to create a new step with independent callbacks.</p> <p>Example</p> <pre><code>var seen = new List&lt;string&gt;();\n\nimposter.Increment(Arg&lt;int&gt;.Any())\n    .Returns(_ =&gt; 10)\n    .Callback(_ =&gt; seen.Add(\"first\"))\n    .Then()\n    .Returns(_ =&gt; 20)\n    .Callback(_ =&gt; seen.Add(\"second\"));\n\nservice.Increment(1); // adds \"first\"\nservice.Increment(2); // adds \"second\"\n</code></pre>"},{"location":"methods/callbacks/#callbacks-that-throw","title":"Callbacks that throw","text":"<p>If a callback throws, the exception is propagated to the caller after the result has been produced.</p> <p>Example</p> <pre><code>// See more examples in repo tests\nimposter.GetNumber()\n    .Returns(1)\n    .Callback(() =&gt; throw new InvalidOperationException(\"boom\"));\n\n// service.GetNumber() returns 1, then throws InvalidOperationException\n</code></pre>"},{"location":"methods/callbacks/#tips","title":"Tips","text":"<ul> <li>Prefer small, deterministic callbacks; reserve complex state changes for your SUT or helpers.</li> <li>When mixing <code>Returns</code> and <code>Callback</code>, callbacks always run last for that sequence step.</li> </ul>"},{"location":"methods/explicit-vs-implicit/","title":"Imposter Modes (Methods)","text":"<p>Two Imposter modes determine what happens when a method without a setup is invoked.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IMyService))]\n\npublic interface IMyService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre> <p>Pro tip</p> <p>Default to <code>Explicit</code> in unit tests to catch missing setups early. Use <code>Implicit</code> in spike/prototyping code where default results are acceptable.</p>"},{"location":"methods/explicit-vs-implicit/#implicit-mode","title":"Implicit mode","text":"<p>Methods without a setups are implicitly stubbed and return <code>default(T)</code>.</p> <p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/ImposterModesTests.cs#L21\"}</p> <p>var imposter = new IMyServiceImposter(ImposterMode.Implicit); var service = imposter.Instance();</p> <p>// Method without a setup =&gt; default(int) == 0 int n = service.GetNumber(); // 0</p> <p>// Add a setup and the call returns your value imposter.GetNumber().Returns(42); service.GetNumber(); // 42</p> <p>// Async methods imposter.GetNumberAsync().ReturnsAsync(7); var v = await service.GetNumberAsync(); // 7     ```</p>"},{"location":"methods/explicit-vs-implicit/#explicit-mode","title":"Explicit mode","text":"<p>Missing setups throw an exception so unintended calls are caught.</p> <p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/ImposterModesTests.cs#L41\"}</p> <p>var imposter = new IMyServiceImposter(ImposterMode.Explicit); var service = imposter.Instance();</p> <p>// No setup -&gt; throws MissingImposterException Assert.Throws(() =&gt; service.GetNumber()); <p>// Add a setup -&gt; call succeeds imposter.GetNumber().Returns(42); service.GetNumber(); // 42     ```</p> <p>View more examples on GitHub.</p>"},{"location":"methods/protected-members/","title":"Protected Methods","text":"<p>Overrideable protected members of the class can be mocked just like other overridable class members.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.Protected.MyService))]\n\nnamespace Imposter.Tests.Docs.Methods.Protected\n{\n    public class MyService\n    {\n        protected virtual int ProtectedAdd(int value) =&gt; value * 2;\n        public virtual int InvokeProtected(int value) =&gt; ProtectedAdd(value);\n    }\n}\n</code></pre>"},{"location":"methods/protected-members/#example","title":"Example","text":"<p>Example</p> <p>```csharp {data-gh-link=\"https://github.com/themidnightgospel/Imposter/blob/master/tests/Imposter.Tests/Docs/Methods/ProtectedMembersTests.cs#L20\"}</p> <p>// Class target with a protected virtual method and a public wrapper that calls it [assembly: GenerateImposter(typeof(MyService))]</p> <p>public class MyService {     protected virtual int ProtectedAdd(int value) =&gt; value * 2;     public virtual int InvokeProtected(int value) =&gt; ProtectedAdd(value); }</p> <p>var imp = new MyServiceImposter();</p> <p>// Arrange the protected method directly on the imposter imp.ProtectedAdd(Arg.Is(5)).Returns(42); <p>// Forward the public wrapper to the real implementation so it calls the protected member imp.InvokeProtected(Arg.Any()).UseBaseImplementation(); <p>var svc = imp.Instance(); svc.InvokeProtected(5).ShouldBe(42);     ```</p> <p>See more examples on GitHub.</p>"},{"location":"methods/sequential-returns/","title":"Sequential Returns","text":"<p>Imposter supports sequencing multiple outcomes for the same method using <code>Then()</code>. This is useful for modeling stateful behavior across repeated calls.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.ISeqService))]\n\npublic interface ISeqService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre>"},{"location":"methods/sequential-returns/#basic-sequencing","title":"Basic sequencing","text":"<p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Returns(2)\n    .Then().Returns(3);\n\nservice.GetNumber(); // 1\nservice.GetNumber(); // 2\nservice.GetNumber(); // 3\n</code></pre>"},{"location":"methods/sequential-returns/#mixing-delegates","title":"Mixing delegates","text":"<p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(() =&gt; 1)\n    .Then().Returns(() =&gt; 2);\n</code></pre>"},{"location":"methods/sequential-returns/#async-sequences","title":"Async sequences","text":"<p>Example</p> <pre><code>imposter.GetNumberAsync()\n    .ReturnsAsync(1)\n    .Then().Returns(() =&gt; Task.FromResult(2));\n</code></pre>"},{"location":"methods/sequential-returns/#interleaving-exceptions","title":"Interleaving exceptions","text":"<p>You can interleave <code>Throws</code> within a sequence. Separate each step with <code>Then()</code>.</p> <p>Example</p> <pre><code>// See more examples in repo tests\nimposter.GetNumber()\n    .Returns(1)\n    .Then().Throws&lt;InvalidOperationException&gt;()\n    .Then().Returns(2);\n</code></pre> <p>Pro tip</p> <ul> <li>Always use <code>Then()</code> between distinct outcomes.</li> <li>Repeating <code>Returns</code> (or <code>Throws</code>) without <code>Then()</code> is invalid.</li> <li>You can mix <code>Returns</code>, <code>ReturnsAsync</code>, <code>Throws</code>, and <code>UseBaseImplementation()</code> across steps for class targets.</li> </ul>"},{"location":"methods/sequential-returns/#concurrency-note","title":"Concurrency note","text":"<p>Under concurrent calls, outcomes are consumed in order. When a sequence is exhausted, behavior falls back to the last applicable outcome or to default behavior (depending on the target and mode).</p>"},{"location":"methods/throwing/","title":"Throwing Exceptions","text":"<p>Arrange methods to throw exceptions instead of returning values. This is useful for testing exception paths and retry logic.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IThrowService))]\n\npublic interface IThrowService\n{\n    int GetNumber();\n    System.Threading.Tasks.Task&lt;int&gt; GetNumberAsync();\n}\n</code></pre>"},{"location":"methods/throwing/#ways-to-throw","title":"Ways to throw","text":"<ul> <li>Generic type:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws&lt;InvalidOperationException&gt;();\n</code></pre> <ul> <li>Specific instance:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws(new Exception(\"boom\"));\n</code></pre> <ul> <li>Factory delegate:</li> </ul> <p>Example</p> <pre><code>imposter.GetNumber().Throws(() =&gt; new Exception(\"deferred\"));\n</code></pre>"},{"location":"methods/throwing/#sequencing-with-returns","title":"Sequencing with returns","text":"<p>Mix <code>Throws</code> with <code>Returns</code> using <code>Then()</code>:</p> <p>Example</p> <pre><code>imposter.GetNumber()\n    .Returns(1)\n    .Then().Throws&lt;InvalidOperationException&gt;()\n    .Then().Returns(2);\n</code></pre>"},{"location":"methods/throwing/#async-methods","title":"Async methods","text":"<p>For Task/Task or ValueTask/ValueTask, <code>Throws</code> raises the exception when the method is invoked, just like synchronous methods. Use async-aware assertions in tests when appropriate. <p>Example</p> <pre><code>imposter.GetNumberAsync().Throws&lt;TimeoutException&gt;();\nawait Assert.ThrowsAsync&lt;TimeoutException&gt;(() =&gt; service.GetNumberAsync());\n</code></pre> <p>See more examples on GitHub.</p>"},{"location":"methods/throwing/#interactions-with-explicit-mode","title":"Interactions with Explicit mode","text":"<p>In <code>ImposterMode.Explicit</code>, a missing setup already throws <code>MissingImposterException</code>. Prefer arranging <code>Throws</code> when you need a specific exception type or message rather than a generic missing-setup exception.</p>"},{"location":"methods/throwing/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Repeating <code>Throws</code> without <code>Then()</code> is invalid; separate distinct throwing steps with <code>Then()</code>.</li> <li>When combining callbacks, callbacks execute after the exception is produced.</li> </ul>"},{"location":"methods/verification/","title":"Verification","text":"<p>Verify that methods were invoked the expected number of times with specific arguments. Use <code>Called(Count.*)</code> on the method builder.</p> <p>Target type used in examples:</p> <p>Example</p> <pre><code>using Imposter.Abstractions;\n\n[assembly: GenerateImposter(typeof(Imposter.Tests.Docs.Methods.IVerifyService))]\n\npublic interface IVerifyService\n{\n    void Increment(int v);\n    int Combine(int a, int b);\n}\n</code></pre>"},{"location":"methods/verification/#semantics","title":"Semantics","text":"<ul> <li><code>Called(Count)</code> counts only invocations that match the builder\u2019s argument matchers.</li> <li><code>Count.Once()</code> is an alias for <code>Count.Exactly(1)</code>.</li> <li><code>Count.Exactly(n)</code> requires the matching call count to equal <code>n</code>.</li> <li><code>Count.AtLeast(n)</code> requires the count to be <code>&gt;= n</code>.</li> <li><code>Count.AtMost(n)</code> requires the count to be <code>&lt;= n</code>.</li> <li><code>Count.Never()</code> requires zero matching calls.</li> <li><code>Count.Any</code> imposes no constraint and always succeeds.</li> </ul>"},{"location":"methods/verification/#basic-counts","title":"Basic counts","text":"<p>Example</p> <pre><code>service.Increment(1);\nservice.Increment(2);\n\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Increment(2).Called(Count.Once());\n</code></pre>"},{"location":"methods/verification/#count-helpers","title":"Count helpers","text":"<ul> <li><code>Count.Exactly(n)</code> \u2014 exactly n times</li> <li><code>Count.AtLeast(n)</code> \u2014 n or more times</li> <li><code>Count.AtMost(n)</code> \u2014 n or fewer times</li> <li><code>Count.Once()</code> \u2014 exactly once</li> <li><code>Count.Never()</code> \u2014 zero times</li> <li><code>Count.Any</code> \u2014 any number of times</li> </ul>"},{"location":"methods/verification/#matching-arguments","title":"Matching arguments","text":"<p>Verification respects the same argument matching rules used for arrangements:</p> <p>Example</p> <pre><code>// See more examples in repo tests\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 10)).Called(Count.Exactly(3));\nimposter.Combine(Arg&lt;int&gt;.Is(x =&gt; x &gt; 0), Arg&lt;int&gt;.Is(y =&gt; y &lt; 10)).Called(Count.Once());\n</code></pre>"},{"location":"methods/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown. Message format:</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\n</code></pre> <p>Examples:</p> <pre><code>// Expected at least 2, only 1 occurred\nservice.Increment(1);\nimposter.Increment(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\n// throws VerificationFailedException with:\n// \"Invocation was expected to be performed at least 2 time(s) but instead was performed 1 times.\"\n\n// Expected exactly 3, got 2\nservice.Increment(10);\nservice.Increment(11);\nimposter.Increment(Arg&lt;int&gt;.Is(x =&gt; x &gt; 5)).Called(Count.Exactly(3));\n// throws VerificationFailedException with:\n// \"Invocation was expected to be performed exactly 3 time(s) but instead was performed 2 times.\"\n</code></pre>"},{"location":"methods/verification/#tips","title":"Tips","text":"<ul> <li>Prefer verifying behavior at the boundary of your SUT rather than implementation details.</li> <li>Verification can be chained after prior setups via <code>Then()</code>, but is typically run after exercising your SUT.</li> </ul>"},{"location":"properties/","title":"Property Mocking","text":"<p>Configure getters and setters, verify writes, and forward to base implementations for class targets.</p>"},{"location":"properties/#getter","title":"Getter","text":"<pre><code>imposter.Age.Getter().Returns(33);\nvar value = service.Age; // 33\n\n// Sequencing\nimposter.Age.Getter().Returns(10).Then().Returns(20);\n</code></pre>"},{"location":"properties/#setter","title":"Setter","text":"<pre><code>// Observe writes\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt; { /* side-effects */ });\n\n// Verify writes\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.Exactly(1));\n</code></pre>"},{"location":"properties/#base-implementation","title":"Base Implementation","text":"<p>Forward to the base implementation for overridable class members:</p> <pre><code>imposter.Age.Getter().UseBaseImplementation();\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).UseBaseImplementation();\n</code></pre>"},{"location":"properties/#defaults-and-initializers","title":"Defaults and Initializers","text":"<ul> <li>Implicit mode: missing getter setups return defaults.</li> <li>For class targets with property initializers, the first read mirrors the initialized base value.</li> </ul> <p>Pro tip</p> <p>When porting existing code, prefer <code>UseBaseImplementation()</code> on getters/setters to preserve current domain behavior while you incrementally add setups.</p>"},{"location":"properties/#tips","title":"Tips","text":"<ul> <li>Combine <code>Called(Count.*)</code> with your setter setups to validate write frequency.</li> <li>In Explicit mode, missing setups throw <code>MissingImposterException</code>.</li> <li>See tests under <code>tests/Imposter.Tests/Features/PropertyImposter/*</code> for edge cases and thread-safety.</li> </ul>"},{"location":"properties/base-implementation/","title":"Property Base Implementation","text":"<p>Forward to the base implementation for overridable class members.</p> <pre><code>imposter.Age.Getter().UseBaseImplementation();\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).UseBaseImplementation();\n</code></pre> <p>Notes - For class targets with initializers, the first read mirrors the initialized value. - In Explicit mode, if base is unavailable and no setup matches, <code>MissingImposterException</code> is thrown. - Getter builders can now interleave <code>UseBaseImplementation()</code> with <code>Then()</code>/<code>Returns(...)</code>/<code>Throws(...)</code>, so you can sequence base \u2192 custom \u2192 base just like you already can with indexers.</p>"},{"location":"properties/callbacks/","title":"Property Callbacks","text":"<p>Run side effects when a property is written or read.</p>"},{"location":"properties/callbacks/#setter-callbacks","title":"Setter callbacks","text":"<pre><code>imposter.Age.Setter(Arg&lt;int&gt;.Any()).Callback(v =&gt;\n{\n    // observe or react to writes\n});\n</code></pre>"},{"location":"properties/callbacks/#getter-callbacks","title":"Getter callbacks","text":"<pre><code>imposter.Age.Getter().Callback(() =&gt;\n{\n    // observe reads; combine with Returns/Then\n}).Returns(10);\n</code></pre> <p>Tips - Use <code>Arg&lt;T&gt;</code> to scope callbacks to specific values. - Combine with <code>Called(Count.\u2026)</code> for verification.</p>"},{"location":"properties/imposter-modes/","title":"Imposter Modes (Properties)","text":"<p>How property getters and setters behave when you didn\u2019t set them up.</p>"},{"location":"properties/imposter-modes/#implicit-mode","title":"Implicit mode","text":"<p>Getters without setups return default values like <code>0</code>, <code>null</code>, or <code>default(T)</code>.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Implicit);\nvar service = imposter.Instance();\n\n// Getter without a setup =&gt; default(int) == 0\nint age = service.Age; // 0\n\n// Add a getter setup\nimposter.Age.Getter().Returns(33);\nage = service.Age; // 33\n\n// Setters work without setups; verify writes\nservice.Age = 10;\nimposter.Age.Setter(Arg&lt;int&gt;.Is(10)).Called(Count.Once());\n</code></pre>"},{"location":"properties/imposter-modes/#explicit-mode","title":"Explicit mode","text":"<p>Getters without setups throw so unintended reads are caught.</p> <pre><code>var imposter = new IMyServiceImposter(ImposterMode.Explicit);\nvar service = imposter.Instance();\n\n// No getter setup -&gt; throws MissingImposterException\nAssert.Throws&lt;MissingImposterException&gt;(() =&gt; { var _ = service.Age; });\n\n// Add a getter setup -&gt; read succeeds\nimposter.Age.Getter().Returns(10);\nvar value = service.Age; // 10\n\n// Setters can still be verified\nservice.Age = 5;\nimposter.Age.Setter(Arg&lt;int&gt;.Is(5)).Called(Count.Once());\n</code></pre>"},{"location":"properties/imposter-modes/#calling-real-code-on-classes","title":"Calling real code on classes","text":"<p>Forward to the class\u2019s own implementation for overridable properties:</p> <pre><code>imposter.Age.Getter().UseBaseImplementation();\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).UseBaseImplementation();\n</code></pre> <p>See also: <code>tests/Imposter.Tests/Features/PropertyImposter/PropertyDefaultBehaviour.cs</code>.</p>"},{"location":"properties/protected-members/","title":"Protected Properties","text":"<p>Configure protected virtual properties on class targets and read/write them through public wrappers.</p>"},{"location":"properties/protected-members/#gettersetter-with-wrapper","title":"Getter/Setter with wrapper","text":"<pre><code>[assembly: GenerateImposter(typeof(MyService))]\n\npublic class MyService\n{\n    protected virtual int ProtectedAge { get; set; } = 7;\n    public virtual int ReadProtected() =&gt; ProtectedAge;\n    public virtual void WriteProtected(int value) =&gt; ProtectedAge = value;\n}\n\nvar imp = new MyServiceImposter();\n\n// Arrange getter\nimp.ProtectedAge.Getter().Returns(33);\n\n// Forward wrappers to call the protected accessors\nimp.ReadProtected().UseBaseImplementation();\nimp.WriteProtected(Arg&lt;int&gt;.Any()).UseBaseImplementation();\n\nvar svc = imp.Instance();\nsvc.ReadProtected(); // 33\n\nsvc.WriteProtected(10);\nimp.ProtectedAge.Setter(Arg&lt;int&gt;.Is(10)).Called(Count.Once());\n</code></pre> <p>Notes - Class targets only; property must be overridable. - Wrapper methods used to call the protected property must be <code>virtual</code> to be configurable on the imposter. - Verify reads/writes with <code>Called(Count.*)</code> using wrapper or direct property setup.</p>"},{"location":"properties/sequential-returns/","title":"Property Sequential Returns","text":"<p>Return a sequence of values on successive reads.</p> <pre><code>imposter.Age.Getter()\n    .Returns(10)\n    .Then().Returns(20)\n    .Then().Returns(30);\n\nvar a = service.Age; // 10\nvar b = service.Age; // 20\nvar c = service.Age; // 30\n</code></pre> <p>Combine sequencing with callbacks if you need to record read order.</p>"},{"location":"properties/throwing/","title":"Property Throwing","text":"<p>In Explicit mode or when desired, configure getters to throw.</p> <pre><code>imposter.Age.Getter().Throws&lt;InvalidOperationException&gt;();\n\n// Or use a factory\nimposter.Age.Getter().Throws(() =&gt; new Exception(\"boom\"));\n</code></pre> <p>Setter validations typically use <code>Called(Count.\u2026)</code>; prefer throws on getter for read-time failures.</p>"},{"location":"properties/verification/","title":"Property Verification","text":"<p>Verify reads and writes using <code>Called</code> with <code>Count</code> helpers.</p>"},{"location":"properties/verification/#semantics","title":"Semantics","text":"<ul> <li>Setter verification: <code>imposter.Property.Setter(matchers...).Called(Count)</code> counts only writes whose value matches the provided matcher (or any value when using <code>Any()</code>).</li> <li>Getter verification: <code>imposter.Property.Getter().Called(Count)</code> counts reads of the property.</li> <li>Count helpers behave the same as for methods: <code>Once = Exactly(1)</code>, <code>Exactly(n)</code>, <code>AtLeast(n)</code>, <code>AtMost(n)</code>, <code>Never()</code>, <code>Any</code>.</li> </ul>"},{"location":"properties/verification/#setter-verification","title":"Setter verification","text":"<pre><code>service.Age = 33;\nservice.Age = 34;\n\nimposter.Age.Setter(Arg&lt;int&gt;.Any()).Called(Count.AtLeast(2));\nimposter.Age.Setter(Arg&lt;int&gt;.Is(34)).Called(Count.Once());\n</code></pre>"},{"location":"properties/verification/#getter-verification","title":"Getter verification","text":"<pre><code>var _ = service.Age;\nimposter.Age.Getter().Called(Count.Once());\n</code></pre>"},{"location":"properties/verification/#failures","title":"Failures","text":"<p>When verification fails, <code>VerificationFailedException</code> is thrown with the message:</p> <pre><code>Invocation was expected to be performed {expectedCount} but instead was performed {actualCount} times.\n</code></pre> <p>Examples:</p> <pre><code>// Setter expected once for value 34, but no matching write occurred\nimposter.Age.Setter(Arg&lt;int&gt;.Is(34)).Called(Count.Once());\n// throws: \"Invocation was expected to be performed exactly 1 time(s) but instead was performed 0 times.\"\n\n// Getter expected at least 2 reads, but only 1\nvar _ = service.Age;\nimposter.Age.Getter().Called(Count.AtLeast(2));\n// throws: \"Invocation was expected to be performed at least 2 time(s) but instead was performed 1 times.\"\n</code></pre> <p>Tips - Use <code>Arg&lt;T&gt;</code> matchers to target specific values. - Pair verifications with callbacks when you need to capture payloads.</p>"}]}